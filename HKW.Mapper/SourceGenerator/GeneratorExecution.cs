using System.CodeDom.Compiler;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace HKW.HKWMapper.SourceGenerator;

internal partial class GeneratorExecution
{
    public static GeneratorExecution Load(GeneratorExecutionContext context)
    {
        return new() { ExecutionContext = context };
    }

    public GeneratorExecutionContext ExecutionContext { get; private set; }

    public void Execute()
    {
        var compilation = LoadMapMethod();
        if (compilation is null)
            return;
        foreach (var compilationSyntaxTree in compilation.SyntaxTrees)
        {
            ParseSyntaxTree(compilation, compilationSyntaxTree);
        }
    }

    public Compilation? LoadMapMethod()
    {
        var compilation = ExecutionContext.Compilation;
        var mapMethods = new HashSet<string>();
        foreach (var compilationSyntaxTree in compilation.SyntaxTrees)
        {
            foreach (var mapMethod in GetMapMethods(compilationSyntaxTree))
                mapMethods.Add(mapMethod);
        }

        if (mapMethods.Count == 0)
            return null;
        var stringStream = GenerateMapMethods(mapMethods);

        // 将生成的代码添加到生成器中, 否则将无法正确识别创建的特性
        var attributeSourceText = SourceText.From(
            stringStream.ToString(),
            System.Text.Encoding.UTF8
        );
        ExecutionContext.AddSource($"MapAttributes.g.cs", attributeSourceText);
        var options = ((CSharpCompilation)ExecutionContext.Compilation).SyntaxTrees[0].Options;
        var attributeTree = CSharpSyntaxTree.ParseText(
            attributeSourceText,
            (CSharpParseOptions)options
        );
        return ExecutionContext.Compilation.AddSyntaxTrees(attributeTree);
    }

    public StringWriter GenerateMapMethods(HashSet<string> mapMethods)
    {
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;

        foreach (var mapMethod in mapMethods)
        {
            writer.WriteLine(
                @$"
/// <summary>
/// {mapMethod}PropertyAttribute
/// <para>This attribute is only used in <c>{mapMethod}</c></para>
/// </summary>
[AttributeUsage(AttributeTargets.Property, AllowMultiple = true)]
public sealed class {mapMethod}PropertyAttribute : Attribute
{{
    /// <inheritdoc/>
    public {mapMethod}PropertyAttribute(string PropertyName)
    {{
        this.PropertyName = PropertyName;
    }}

    /// <inheritdoc/>
    public {mapMethod}PropertyAttribute(Type ConverterType)
    {{
        this.ConverterType = ConverterType;
    }}

    /// <summary>
    /// PropertyName
    /// <para>Default is current property name</para>
    /// </summary>
    public string? PropertyName {{ get; set; }}

    /// <summary>
    /// PropertyAction
    /// <para>Default is <c>[source|traget].{{value}}</c></para>
    /// <para>e.g. <c>source.{{value}}.ToString()</c>, <c>int.Parse(source.{{value}})</c> etc.</para>
    /// </summary>
    public string? PropertyAction {{ get; set; }}

    /// <summary>
    /// ConverterType
    /// </summary>
    public Type? ConverterType {{ get; set; }}
}}
/// <summary>
/// {mapMethod}IgnorePropertyAttribute
/// <para>This attribute is only used in <c>{mapMethod}</c></para>
/// </summary>
[AttributeUsage(AttributeTargets.Property)]
public sealed class {mapMethod}IgnorePropertyAttribute : Attribute {{ }}"
            );
        }

        writer.Indent--;
        writer.WriteLine("}");
        return stringStream;
    }

    private HashSet<string> GetMapMethods(SyntaxTree compilationSyntaxTree)
    {
        var mapMethods = new HashSet<string>();
        var semanticModel = ExecutionContext.Compilation.GetSemanticModel(compilationSyntaxTree);
        var declaredClasses = compilationSyntaxTree
            .GetRoot()
            .DescendantNodesAndSelf()
            .OfType<ClassDeclarationSyntax>();
        foreach (var declaredClass in declaredClasses)
        {
            var classSymbol = (INamedTypeSymbol)
                ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass)!;
            var attributeDatas = classSymbol
                .GetAttributes()
                .Where(x =>
                    x.AttributeClass!.ToString() is string name
                    && (
                        name == typeof(MapToAttribute).FullName
                        || name == typeof(MapFromAttribute).FullName
                    )
                );
            foreach (var attribute in attributeDatas)
            {
                var attributeName = attribute.AttributeClass!.GetFullName();
                if (attributeName == typeof(MapToAttribute).FullName)
                {
                    if (attribute.TryGetAttributeAndValues(out var datas) is false)
                        continue;
                    if (
                        datas.TryGetValue(nameof(MapToAttribute.TargetType), out var value) is false
                    )
                        continue;
                    datas.TryGetValue(nameof(MapToAttribute.MethodName), out var methodData);
                    var methodName = methodData.Value?.Value?.ToString();
                    var type = (INamedTypeSymbol)value.Value!.Value.Value!;
                    if (string.IsNullOrWhiteSpace(methodName))
                        methodName = $"{classSymbol.Name}MapTo{type.Name}";
                    if (mapMethods.Add(methodName!) is false)
                    {
                        var errorDiagnostic = Diagnostic.Create(
                            Descriptors.SameMethodNameDescriptor,
                            attribute.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                                attribute.ApplicationSyntaxReference.Span
                            ),
                            methodName
                        );
                        ExecutionContext.ReportDiagnostic(errorDiagnostic);
                    }
                }
                else if (attributeName == typeof(MapFromAttribute).FullName)
                {
                    if (attribute.TryGetAttributeAndValues(out var datas) is false)
                        continue;
                    if (
                        datas.TryGetValue(nameof(MapToAttribute.TargetType), out var value) is false
                    )
                        continue;
                    datas.TryGetValue(nameof(MapToAttribute.MethodName), out var methodData);
                    var methodName = methodData.Value?.Value?.ToString();
                    var type = (INamedTypeSymbol)value.Value!.Value.Value!;
                    if (string.IsNullOrWhiteSpace(methodName))
                        methodName = $"{classSymbol.Name}MapFrom{type.Name}";
                    if (mapMethods.Add(methodName!) is false)
                    {
                        var errorDiagnostic = Diagnostic.Create(
                            Descriptors.SameMethodNameDescriptor,
                            classSymbol.Locations[0],
                            methodName
                        );
                        ExecutionContext.ReportDiagnostic(errorDiagnostic);
                    }
                }
            }
        }
        return mapMethods;
    }

    private void ParseSyntaxTree(Compilation compilation, SyntaxTree syntaxTree)
    {
        var semanticModel = compilation.GetSemanticModel(syntaxTree);
        var declaredClasses = syntaxTree
            .GetRoot()
            .DescendantNodesAndSelf()
            .OfType<ClassDeclarationSyntax>();

        var mapMethodsByType = GetMapTargetAndMethod(semanticModel, declaredClasses);
        var converters = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        foreach (var map in mapMethodsByType)
        {
            GenerateMap(compilation, syntaxTree, converters, map);
        }

        if (converters.Count > 0)
        {
            GenerateComverter(syntaxTree, converters);
        }
    }

    private void GenerateMap(
        Compilation compilation,
        SyntaxTree compilationSyntaxTree,
        HashSet<INamedTypeSymbol> converters,
        KeyValuePair<
            INamedTypeSymbol,
            (
                HashSet<(INamedTypeSymbol Type, string MethodName)> ToMethods,
                HashSet<(INamedTypeSymbol Type, string MethodName)> FromMethods
            )
        > pair
    )
    {
        var usings = ((CompilationUnitSyntax)compilationSyntaxTree.GetRoot()).Usings;
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine(usings);
        writer.WriteLine("#pragma warning disable CS8604");
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("/// <summary>MapperExtensions</summary>");
        writer.WriteLine($"public static partial class MapperExtensions");
        writer.WriteLine("{");
        writer.Indent++;
        foreach (var target in pair.Value.ToMethods)
        {
            GenerateToMethod(compilation, converters, pair.Key, writer, target);
        }

        foreach (var target in pair.Value.FromMethods)
        {
            GenerateFromMethod(compilation, converters, pair.Key, writer, target);
        }

        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
        ExecutionContext.AddSource(
            $"{pair.Key.GetFullNameAndGeneric(true)}.Mapper.g.cs",
            stringStream.ToString()
        );
    }

    private void GenerateFromMethod(
        Compilation compilation,
        HashSet<INamedTypeSymbol> converters,
        INamedTypeSymbol sourceType,
        IndentedTextWriter writer,
        (INamedTypeSymbol Type, string MethodName) target
    )
    {
        var accessibility = sourceType.GetLowestAccessibility(target.Type);
        writer.WriteLine(
            $"{accessibility} static {sourceType.GetFullNameAndGeneric()} {target.MethodName}(this {sourceType.GetFullNameAndGeneric()} source, {target.Type.GetFullNameAndGeneric()} target)"
        );
        writer.WriteLine("{");
        writer.Indent++;
        var mapPropertyAttributeName = NativeUtils.GetMapPropertyAttributeName(
            sourceType,
            target.MethodName
        );
        var mapIgnorePropertyAttributeName = NativeUtils.GetMapIgnorePropertyAttributeName(
            sourceType,
            target.MethodName
        );
        foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
        {
            // 如果是静态属性,则跳过
            if (property.IsStatic)
                continue;
            var attributes = property.GetAttributes();
            if (
                attributes.Any(x =>
                    x.AttributeClass?.GetFullName() == mapIgnorePropertyAttributeName
                    || x.AttributeClass?.GetFullName()
                        == typeof(MapIgnorePropertyAttribute).FullName
                )
            )
                continue;
            var attributeDatas = attributes.Where(x =>
                x.AttributeClass!.GetFullName() == mapPropertyAttributeName
            );
            // 如果没有特性,则直接使用同名属性
            if (attributeDatas?.Any() is null)
            {
                // 如果目标属性不存在或者没有Set方法或者是静态属性,则跳过
                if (
                    target.Type.GetMembers(property.Name).OfType<IPropertySymbol>().FirstOrDefault()
                        is not IPropertySymbol targetProperty1
                    || targetProperty1.SetMethod is null
                    || targetProperty1.IsStatic
                )
                    continue;
                writer.WriteLine($"source.{property.Name} = target.{property.Name};");
                continue;
            }
            var targetPropertys = new HashSet<string>();
            foreach (var attributeData in attributeDatas)
            {
                var targetPropertyName = property.Name;
                string? propertyAction = null;
                INamedTypeSymbol? converterType = null;
                if (attributeData?.TryGetAttributeAndValues(out var datas) is true)
                {
                    if (
                        datas.TryGetValue(
                            nameof(MapPropertyAttribute.PropertyName),
                            out var nameData
                        )
                    )
                    {
                        var name = nameData.Value?.Value?.ToString();
                        if (string.IsNullOrWhiteSpace(name) is false)
                            targetPropertyName = name;
                    }
                    if (
                        datas.TryGetValue(
                            nameof(MapPropertyAttribute.PropertyAction),
                            out var actionData
                        )
                    )
                    {
                        var action = actionData.Value?.Value?.ToString();
                        if (string.IsNullOrWhiteSpace(action) is false)
                            propertyAction = action!.Replace("{value}", targetPropertyName);
                    }
                    if (
                        datas.TryGetValue(
                            nameof(MapPropertyAttribute.ConverterType),
                            out var converterData
                        )
                    )
                    {
                        converterType = converterData.Value?.Value as INamedTypeSymbol;
                        if (converterType is not null)
                        {
                            if (
                                converterType.Interfaces.Any(x =>
                                    SymbolEqualityComparer.Default.Equals(
                                        x.OriginalDefinition,
                                        compilation.GetTypeByMetadataName(
                                            typeof(IMapConverter<,>).FullName
                                        )
                                    )
                                )
                                is false
                            )
                            {
                                var errorDiagnostic = Diagnostic.Create(
                                    Descriptors.ConverterDescriptor,
                                    attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                                        attributeData.ApplicationSyntaxReference.Span
                                    ),
                                    converterType.Name
                                );
                                ExecutionContext.ReportDiagnostic(errorDiagnostic);
                            }
                            converters.Add(converterType);
                        }
                    }
                    // 如果有两个特性使用了相同的目标属性
                    if (targetPropertys.Add(targetPropertyName!) is false)
                    {
                        var errorDiagnostic = Diagnostic.Create(
                            Descriptors.SameTargetNameDescriptor,
                            attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                                attributeData.ApplicationSyntaxReference.Span
                            ),
                            targetPropertyName
                        );
                        ExecutionContext.ReportDiagnostic(errorDiagnostic);
                    }
                }
                // 如果目标类型不存在属性名或者是静态属性,则跳过
                if (
                    target
                        .Type.GetMembers(targetPropertyName!)
                        .OfType<IPropertySymbol>()
                        .FirstOrDefault()
                        is not IPropertySymbol targetProperty
                    || targetProperty.SetMethod is null
                    || targetProperty.IsStatic
                )
                    continue;
                propertyAction ??= $"target.{targetPropertyName}";
                if (converterType is not null)
                {
                    writer.WriteLine(
                        $"source.{property.Name} = {converterType.Name}.{nameof(IMapConverter.ConvertBack)}(target, {propertyAction});"
                    );
                }
                else
                {
                    writer.WriteLine($"source.{property.Name} = {propertyAction};");
                }
            }
        }
        writer.WriteLine("return source;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    private void GenerateToMethod(
        Compilation compilation,
        HashSet<INamedTypeSymbol> converters,
        INamedTypeSymbol sourceType,
        IndentedTextWriter writer,
        (INamedTypeSymbol Type, string MethodName) target
    )
    {
        var accessibility = sourceType.GetLowestAccessibility(target.Type);
        writer.WriteLine(
            $"{accessibility} static {target.Type.GetFullNameAndGeneric()} {target.MethodName}(this {sourceType.GetFullNameAndGeneric()} source, {target.Type.GetFullNameAndGeneric()} target)"
        );
        writer.WriteLine("{");
        writer.Indent++;
        var mapPropertyAttributeName = NativeUtils.GetMapPropertyAttributeName(
            sourceType,
            target.MethodName
        );
        var mapIgnorePropertyAttributeName = NativeUtils.GetMapIgnorePropertyAttributeName(
            sourceType,
            target.MethodName
        );
        foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
        {
            var attributes = property.GetAttributes();
            // 如果是静态属性,则跳过
            if (property.IsStatic)
                continue;
            // 如果是被忽略的属性,则跳过
            if (
                attributes.Any(x =>
                    x.AttributeClass?.GetFullName() == mapIgnorePropertyAttributeName
                    || x.AttributeClass?.GetFullName()
                        == typeof(MapIgnorePropertyAttribute).FullName
                )
            )
                continue;
            var attributeDatas = attributes.Where(x =>
                x.AttributeClass!.GetFullName() == mapPropertyAttributeName
            );
            // 如果没有特性,则直接使用同名属性
            if (attributeDatas?.Any() is null)
            {
                // 如果目标属性不存在或者没有Set方法或者是静态属性,则跳过
                if (
                    target.Type.GetMembers(property.Name).OfType<IPropertySymbol>().FirstOrDefault()
                        is not IPropertySymbol targetProperty1
                    || targetProperty1.SetMethod is null
                    || targetProperty1.IsStatic
                )
                    continue;
                writer.WriteLine($"target.{property.Name} = source.{property.Name};");
                continue;
            }
            var targetPropertys = new HashSet<string>();
            foreach (var attributeData in attributeDatas)
            {
                var targetPropertyName = property.Name;
                string? propertyAction = null;
                INamedTypeSymbol? converterType = null;
                if (attributeData?.TryGetAttributeAndValues(out var datas) is true)
                {
                    if (
                        datas.TryGetValue(
                            nameof(MapPropertyAttribute.PropertyName),
                            out var nameData
                        )
                    )
                    {
                        var name = nameData.Value?.Value?.ToString();
                        if (string.IsNullOrWhiteSpace(name) is false)
                            targetPropertyName = name;
                    }
                    if (
                        datas.TryGetValue(
                            nameof(MapPropertyAttribute.PropertyAction),
                            out var actionData
                        )
                    )
                    {
                        var action = actionData.Value?.Value?.ToString();
                        if (string.IsNullOrWhiteSpace(action) is false)
                            propertyAction = action!.Replace("{value}", targetPropertyName);
                    }
                    if (
                        datas.TryGetValue(
                            nameof(MapPropertyAttribute.ConverterType),
                            out var converterData
                        )
                    )
                    {
                        converterType = converterData.Value?.Value as INamedTypeSymbol;
                        if (converterType is not null)
                        {
                            if (
                                converterType.Interfaces.Any(x =>
                                    SymbolEqualityComparer.Default.Equals(
                                        x.OriginalDefinition,
                                        compilation.GetTypeByMetadataName(
                                            typeof(IMapConverter<,>).FullName
                                        )
                                    )
                                )
                                is false
                            )
                            {
                                var errorDiagnostic = Diagnostic.Create(
                                    Descriptors.ConverterDescriptor,
                                    attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                                        attributeData.ApplicationSyntaxReference.Span
                                    ),
                                    converterType.Name
                                );
                                ExecutionContext.ReportDiagnostic(errorDiagnostic);
                            }
                            converters.Add(converterType);
                        }
                    }
                    // 如果有两个特性使用了相同的目标属性
                    if (targetPropertys.Add(targetPropertyName!) is false)
                    {
                        var errorDiagnostic = Diagnostic.Create(
                            Descriptors.SameTargetNameDescriptor,
                            attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                                attributeData.ApplicationSyntaxReference.Span
                            ),
                            targetPropertyName
                        );
                        ExecutionContext.ReportDiagnostic(errorDiagnostic);
                    }
                }
                // 如果目标属性不存在或者没有Set方法或者是静态属性,则跳过
                if (
                    target
                        .Type.GetMembers(targetPropertyName!)
                        .OfType<IPropertySymbol>()
                        .FirstOrDefault()
                        is not IPropertySymbol targetProperty
                    || targetProperty.SetMethod is null
                    || targetProperty.IsStatic
                )
                    continue;
                propertyAction ??= $"source.{property.Name}";
                if (converterType is not null)
                {
                    writer.WriteLine(
                        $"target.{targetPropertyName} = {converterType.Name}.{nameof(IMapConverter.Convert)}(source, {propertyAction});"
                    );
                }
                else
                {
                    writer.WriteLine($"target.{targetPropertyName} = {propertyAction};");
                }
            }
        }
        writer.WriteLine("return target;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    private void GenerateComverter(
        SyntaxTree compilationSyntaxTree,
        HashSet<INamedTypeSymbol> converters
    )
    {
        var usings = ((CompilationUnitSyntax)compilationSyntaxTree.GetRoot()).Usings;
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine(usings);
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine($"public static partial class MapperExtensions");
        writer.WriteLine("{");
        writer.Indent++;
        foreach (var converter in converters)
        {
            var typeFullName = converter.GetFullName();
            var fieldName = $"_{converter.Name.FirstLetterToLower()}";
            writer.WriteLine($"private static {typeFullName}? {fieldName};");
            writer.WriteLine(
                $"{converter.GetAccessibilityString()} static {typeFullName} {converter.Name} => {fieldName} ?? ({fieldName} = new {typeFullName}()); "
            );
        }
        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
        ExecutionContext.AddSource($"MapperConverters.g.cs", stringStream.ToString());
    }

    private Dictionary<
        INamedTypeSymbol,
        (
            HashSet<(INamedTypeSymbol Type, string MethodName)> ToMethods,
            HashSet<(INamedTypeSymbol Type, string MethodName)> FromMethods
        )
    > GetMapTargetAndMethod(
        SemanticModel semanticModel,
        IEnumerable<ClassDeclarationSyntax> declaredClasses
    )
    {
        var mapMethodsByType = new Dictionary<
            INamedTypeSymbol,
            (
                HashSet<(INamedTypeSymbol Type, string MethodName)> ToMethods,
                HashSet<(INamedTypeSymbol Type, string MethodName)> FromMethods
            )
        >(SymbolEqualityComparer.Default);
        foreach (var declaredClass in declaredClasses)
        {
            var classSymbol = (INamedTypeSymbol)
                ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass)!;
            var attributeDatas = classSymbol
                .GetAttributes()
                .Where(x =>
                    x.AttributeClass!.ToString() is string name
                    && (
                        name == typeof(MapToAttribute).FullName
                        || name == typeof(MapFromAttribute).FullName
                    )
                );
            foreach (var attribute in attributeDatas)
            {
                var attributeName = attribute.AttributeClass!.GetFullName();
                if (attributeName == typeof(MapToAttribute).FullName)
                {
                    if (attribute.TryGetAttributeAndValues(out var datas) is false)
                        continue;
                    if (
                        datas.TryGetValue(nameof(MapToAttribute.TargetType), out var value) is false
                    )
                        continue;
                    datas.TryGetValue(nameof(MapToAttribute.MethodName), out var method);
                    var methodName = method.Value?.Value?.ToString();
                    var type = (INamedTypeSymbol)value.Value!.Value.Value!;
                    if (mapMethodsByType.TryGetValue(classSymbol, out var targets) is false)
                        targets = mapMethodsByType[classSymbol] = ([], []);
                    targets.ToMethods.Add(
                        (
                            type,
                            string.IsNullOrWhiteSpace(methodName)
                                ? $"MapTo{type.Name}"
                                : methodName!
                        )
                    );
                }
                else if (attributeName == typeof(MapFromAttribute).FullName)
                {
                    if (attribute.TryGetAttributeAndValues(out var datas) is false)
                        continue;
                    if (
                        datas.TryGetValue(nameof(MapToAttribute.TargetType), out var value) is false
                    )
                        continue;
                    datas.TryGetValue(nameof(MapToAttribute.MethodName), out var method);
                    var methodName = method.Value?.Value?.ToString();
                    var type = (INamedTypeSymbol)value.Value!.Value.Value!;
                    if (mapMethodsByType.TryGetValue(classSymbol, out var targets) is false)
                        targets = mapMethodsByType[type] = ([], []);
                    targets.FromMethods.Add(
                        (
                            type,
                            string.IsNullOrWhiteSpace(methodName)
                                ? $"MapFrom{type.Name}"
                                : methodName!
                        )
                    );
                }
            }
        }
        return mapMethodsByType;
    }
}
