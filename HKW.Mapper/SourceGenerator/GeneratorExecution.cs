using System.CodeDom.Compiler;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace HKW.HKWMapper.SourceGenerator;

internal partial class GeneratorExecution
{
    public static GeneratorExecution Load(GeneratorExecutionContext context)
    {
        return new() { ExecutionContext = context };
    }

    public GeneratorExecutionContext ExecutionContext { get; private set; }

    public void Execute()
    {
        var compilation = LoadMapMethod();
        if (compilation is null)
            return;
        foreach (var compilationSyntaxTree in compilation.SyntaxTrees)
        {
            ParseSyntaxTree(compilation, compilationSyntaxTree);
        }
    }

    public Compilation? LoadMapMethod()
    {
        var compilation = ExecutionContext.Compilation;
        var mapMethods = new HashSet<string>();
        foreach (var compilationSyntaxTree in compilation.SyntaxTrees)
        {
            foreach (var mapMethod in GetMapMethods(compilationSyntaxTree))
                mapMethods.Add(mapMethod);
        }

        if (mapMethods.Count == 0)
            return null;
        var stringStream = GenerateMapMethods(mapMethods);

        // 将生成的代码添加到生成器中, 否则将无法正确识别创建的特性
        var attributeSourceText = SourceText.From(
            stringStream.ToString(),
            System.Text.Encoding.UTF8
        );
        ExecutionContext.AddSource($"MapAttributes.g.cs", attributeSourceText);
        var options = ((CSharpCompilation)ExecutionContext.Compilation).SyntaxTrees[0].Options;
        var attributeTree = CSharpSyntaxTree.ParseText(
            attributeSourceText,
            (CSharpParseOptions)options
        );
        return ExecutionContext.Compilation.AddSyntaxTrees(attributeTree);
    }

    public StringWriter GenerateMapMethods(HashSet<string> mapMethods)
    {
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;

        foreach (var mapMethod in mapMethods)
        {
            writer.WriteLine(
                @$"
/// <summary>
/// {mapMethod}PropertyAttribute
/// <para>This attribute is only used in <c>{mapMethod}</c></para>
/// </summary>
[AttributeUsage(AttributeTargets.Property)]
public sealed class {mapMethod}PropertyAttribute : Attribute
{{
    /// <inheritdoc/>
    public {mapMethod}PropertyAttribute(string PropertyName)
    {{
        this.PropertyName = PropertyName;
    }}

    /// <inheritdoc/>
    public {mapMethod}PropertyAttribute(Type ConverterType)
    {{
        this.ConverterType = ConverterType;
    }}

    /// <summary>
    /// PropertyName
    /// </summary>
    public string? PropertyName {{ get; set; }}

    /// <summary>
    /// PropertyAction
    /// <para>Default is <c>source.{{value}}</c></para>
    /// <para>e.g. <c>source.{{value}}.ToString()</c>, <c>int.Parse(source.{{value}})</c> etc.</para>
    /// </summary>
    public string? PropertyAction {{ get; set; }}

    /// <summary>
    /// ConverterType
    /// </summary>
    public Type? ConverterType {{ get; set; }}
}}
/// <summary>
/// {mapMethod}IgnorePropertyAttribute
/// <para>This attribute is only used in <c>{mapMethod}</c></para>
/// </summary>
[AttributeUsage(AttributeTargets.Property)]
public sealed class {mapMethod}IgnorePropertyAttribute : Attribute {{ }}
"
            );
        }

        writer.Indent--;
        writer.WriteLine("}");
        return stringStream;
    }

    private HashSet<string> GetMapMethods(SyntaxTree compilationSyntaxTree)
    {
        var mapMethods = new HashSet<string>();
        var semanticModel = ExecutionContext.Compilation.GetSemanticModel(compilationSyntaxTree);
        var declaredClasses = compilationSyntaxTree
            .GetRoot()
            .DescendantNodesAndSelf()
            .OfType<ClassDeclarationSyntax>();
        foreach (var declaredClass in declaredClasses)
        {
            var classSymbol = (INamedTypeSymbol)
                ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass)!;
            var attributeDatas = classSymbol
                .GetAttributes()
                .Where(x =>
                    x.AttributeClass!.ToString() is string name
                    && (
                        name == typeof(MapToAttribute).FullName
                        || name == typeof(MapFromAttribute).FullName
                    )
                );
            foreach (var attribute in attributeDatas)
            {
                var attributeName = attribute.AttributeClass!.GetFullName();
                if (attributeName == typeof(MapToAttribute).FullName)
                {
                    if (attribute.TryGetAttributeAndValues(out var datas) is false)
                        continue;
                    if (
                        datas.TryGetValue(nameof(MapToAttribute.TargetType), out var value) is false
                    )
                        continue;
                    datas.TryGetValue(nameof(MapToAttribute.MethodName), out var methodData);
                    var methodName = methodData.Value?.Value?.ToString();
                    var type = (INamedTypeSymbol)value.Value!.Value.Value!;
                    mapMethods.Add(
                        string.IsNullOrWhiteSpace(methodName)
                            ? $"{classSymbol.Name}MapTo{type.Name}"
                            : methodName!
                    );
                }
                else if (attributeName == typeof(MapFromAttribute).FullName)
                {
                    if (attribute.TryGetAttributeAndValues(out var datas) is false)
                        continue;
                    if (
                        datas.TryGetValue(nameof(MapToAttribute.TargetType), out var value) is false
                    )
                        continue;
                    datas.TryGetValue(nameof(MapToAttribute.MethodName), out var methodData);
                    var methodName = methodData.Value?.Value?.ToString();
                    var type = (INamedTypeSymbol)value.Value!.Value.Value!;
                    mapMethods.Add(
                        string.IsNullOrWhiteSpace(methodName)
                            ? $"{classSymbol.Name}MapFrom{type.Name}"
                            : methodName!
                    );
                }
            }
        }
        return mapMethods;
    }

    private void ParseSyntaxTree(Compilation compilation, SyntaxTree compilationSyntaxTree)
    {
        var semanticModel = compilation.GetSemanticModel(compilationSyntaxTree);
        var declaredClasses = compilationSyntaxTree
            .GetRoot()
            .DescendantNodesAndSelf()
            .OfType<ClassDeclarationSyntax>();

        var mapMethodsByType = GetMapTargetAndMethod(semanticModel, declaredClasses);
        var converters = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        foreach (var map in mapMethodsByType)
        {
            GenerateMap(compilationSyntaxTree, converters, map);
        }

        if (converters.Count > 0)
        {
            GenerateComverter(compilationSyntaxTree, converters);
        }
    }

    private void GenerateMap(
        SyntaxTree compilationSyntaxTree,
        HashSet<INamedTypeSymbol> converters,
        KeyValuePair<
            INamedTypeSymbol,
            (
                HashSet<(INamedTypeSymbol Type, string MethodName)> ToMethods,
                HashSet<(INamedTypeSymbol Type, string MethodName)> FromMethods
            )
        > pair
    )
    {
        var usings = ((CompilationUnitSyntax)compilationSyntaxTree.GetRoot()).Usings;
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine(usings);
        writer.WriteLine("#pragma warning disable CS8604");
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("/// <summary>MapperExtensions</summary>");
        writer.WriteLine($"public static partial class MapperExtensions");
        writer.WriteLine("{");
        writer.Indent++;
        foreach (var target in pair.Value.ToMethods)
        {
            GenerateToMethod(converters, pair.Key, writer, target);
        }

        foreach (var target in pair.Value.FromMethods)
        {
            GenerateFromMethod(converters, pair.Key, writer, target);
        }

        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
        ExecutionContext.AddSource(
            $"{pair.Key.GetFullNameAndGeneric(true)}.Mapper.g.cs",
            stringStream.ToString()
        );
    }

    private static void GenerateFromMethod(
        HashSet<INamedTypeSymbol> converters,
        INamedTypeSymbol sourceType,
        IndentedTextWriter writer,
        (INamedTypeSymbol Type, string MethodName) target
    )
    {
        var accessibility = sourceType.GetLowestAccessibility(target.Type);
        writer.WriteLine(
            $"{accessibility} static {sourceType.GetFullNameAndGeneric()} {target.MethodName}(this {sourceType.GetFullNameAndGeneric()} source, {target.Type.GetFullNameAndGeneric()} target)"
        );
        writer.WriteLine("{");
        writer.Indent++;
        var mapPropertyAttributeName =
            $"HKW.HKWMapper.{sourceType.Name}{target.MethodName}PropertyAttribute";
        var mapIgnorePropertyAttributeName =
            $"HKW.HKWMapper.{sourceType.Name}{target.MethodName}IgnorePropertyAttribute";
        foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
        {
            var d = property.DeclaringSyntaxReferences.First();
            var attributeDatas = property.GetAttributes();
            if (attributeDatas.Length > 0)
            {
                if (
                    attributeDatas.Any(x =>
                        x.AttributeClass?.GetFullName() == mapIgnorePropertyAttributeName
                    )
                )
                    continue;
                var attributeData = attributeDatas.FirstOrDefault(x =>
                    x.AttributeClass!.GetFullName() == mapPropertyAttributeName
                );
                if (attributeData is not null)
                {
                    var targetPropertyName = property.Name;
                    string? propertyAction = null;
                    INamedTypeSymbol? converterType = null;
                    if (attributeData?.TryGetAttributeAndValues(out var datas) is true)
                    {
                        if (
                            datas.TryGetValue(
                                nameof(MapPropertyAttribute.PropertyName),
                                out var nameData
                            )
                        )
                        {
                            var name = nameData.Value?.Value?.ToString();
                            if (string.IsNullOrWhiteSpace(name) is false)
                                targetPropertyName = name;
                        }
                        if (
                            datas.TryGetValue(
                                nameof(MapPropertyAttribute.PropertyAction),
                                out var actionData
                            )
                        )
                        {
                            var action = actionData.Value?.Value?.ToString();
                            if (string.IsNullOrWhiteSpace(action) is false)
                                propertyAction = action!.Replace("{value}", targetPropertyName);
                        }
                        if (
                            datas.TryGetValue(
                                nameof(MapPropertyAttribute.ConverterType),
                                out var converterData
                            )
                        )
                        {
                            converterType = converterData.Value?.Value as INamedTypeSymbol;
                            if (converterType is not null)
                                converters.Add(converterType);
                        }
                    }
                    // 如果目标类型不存在属性名,则跳过
                    if (
                        target
                            .Type.GetMembers(targetPropertyName!)
                            .OfType<IPropertySymbol>()
                            .FirstOrDefault()
                        is not IPropertySymbol targetProperty
                    )
                        continue;
                    propertyAction ??= $"target.{targetPropertyName}";
                    if (converterType is not null)
                    {
                        writer.WriteLine(
                            $"source.{property.Name} = {converterType.Name}.{nameof(IMapConverter.ConvertBack)}(target, {propertyAction});"
                        );
                    }
                    else
                    {
                        writer.WriteLine($"source.{property.Name} = {propertyAction};");
                    }
                }
                else
                {
                    if (
                        target
                            .Type.GetMembers(property.Name)
                            .OfType<IPropertySymbol>()
                            .FirstOrDefault()
                        is not IPropertySymbol targetProperty
                    )
                        continue;
                    writer.WriteLine($"source.{property.Name} = target.{property.Name};");
                }
            }
            else
            {
                if (
                    target.Type.GetMembers(property.Name).OfType<IPropertySymbol>().FirstOrDefault()
                    is not IPropertySymbol targetProperty
                )
                    continue;
                writer.WriteLine($"source.{property.Name} = target.{property.Name};");
            }
        }
        writer.WriteLine("return source;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    private static void GenerateToMethod(
        HashSet<INamedTypeSymbol> converters,
        INamedTypeSymbol sourceType,
        IndentedTextWriter writer,
        (INamedTypeSymbol Type, string MethodName) target
    )
    {
        var accessibility = sourceType.GetLowestAccessibility(target.Type);
        writer.WriteLine(
            $"{accessibility} static {target.Type.GetFullNameAndGeneric()} {target.MethodName}(this {sourceType.GetFullNameAndGeneric()} source, {target.Type.GetFullNameAndGeneric()} target)"
        );
        writer.WriteLine("{");
        writer.Indent++;
        var mapPropertyAttributeName =
            $"HKW.HKWMapper.{sourceType.Name}{target.MethodName}PropertyAttribute";
        var mapIgnorePropertyAttributeName =
            $"HKW.HKWMapper.{sourceType.Name}{target.MethodName}IgnorePropertyAttribute";
        foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
        {
            var d = property.DeclaringSyntaxReferences.First();
            var attributeDatas = property.GetAttributes();
            if (attributeDatas.Length > 0)
            {
                if (
                    attributeDatas.Any(x =>
                        x.AttributeClass?.GetFullName() == mapIgnorePropertyAttributeName
                    )
                )
                    continue;
                var attributeData = attributeDatas.FirstOrDefault(x =>
                    x.AttributeClass!.GetFullName() == mapPropertyAttributeName
                );
                if (attributeData is not null)
                {
                    var targetPropertyName = property.Name;
                    string? propertyAction = null;
                    INamedTypeSymbol? converterType = null;
                    if (attributeData?.TryGetAttributeAndValues(out var datas) is true)
                    {
                        if (
                            datas.TryGetValue(
                                nameof(MapPropertyAttribute.PropertyName),
                                out var nameData
                            )
                        )
                        {
                            var name = nameData.Value?.Value?.ToString();
                            if (string.IsNullOrWhiteSpace(name) is false)
                                targetPropertyName = name;
                        }
                        if (
                            datas.TryGetValue(
                                nameof(MapPropertyAttribute.PropertyAction),
                                out var actionData
                            )
                        )
                        {
                            var action = actionData.Value?.Value?.ToString();
                            if (string.IsNullOrWhiteSpace(action) is false)
                                propertyAction = action!.Replace("{value}", targetPropertyName);
                        }
                        if (
                            datas.TryGetValue(
                                nameof(MapPropertyAttribute.ConverterType),
                                out var converterData
                            )
                        )
                        {
                            converterType = converterData.Value?.Value as INamedTypeSymbol;
                            if (converterType is not null)
                                converters.Add(converterType);
                        }
                    }
                    // 如果目标类型不存在属性名,则跳过
                    if (
                        target
                            .Type.GetMembers(targetPropertyName!)
                            .OfType<IPropertySymbol>()
                            .FirstOrDefault()
                        is not IPropertySymbol targetProperty
                    )
                        continue;
                    propertyAction ??= $"source.{targetPropertyName}";
                    if (converterType is not null)
                    {
                        writer.WriteLine(
                            $"target.{property.Name} = {converterType.Name}.{nameof(IMapConverter.Convert)}(source, {propertyAction});"
                        );
                    }
                    else
                    {
                        writer.WriteLine($"target.{property.Name} = {propertyAction};");
                    }
                }
                else
                {
                    if (
                        target
                            .Type.GetMembers(property.Name)
                            .OfType<IPropertySymbol>()
                            .FirstOrDefault()
                        is not IPropertySymbol targetProperty
                    )
                        continue;
                    writer.WriteLine($"target.{property.Name} = source.{property.Name};");
                }
            }
            else
            {
                if (
                    target.Type.GetMembers(property.Name).OfType<IPropertySymbol>().FirstOrDefault()
                    is not IPropertySymbol targetProperty
                )
                    continue;
                writer.WriteLine($"target.{property.Name} = source.{property.Name};");
            }
        }
        writer.WriteLine("return target;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    private void GenerateComverter(
        SyntaxTree compilationSyntaxTree,
        HashSet<INamedTypeSymbol> converters
    )
    {
        var usings = ((CompilationUnitSyntax)compilationSyntaxTree.GetRoot()).Usings;
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine(usings);
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine($"public static partial class MapperExtensions");
        writer.WriteLine("{");
        writer.Indent++;
        foreach (var converter in converters)
        {
            var typeFullName = converter.GetFullName();
            var fieldName = $"_{converter.Name.FirstLetterToLower()}";
            writer.WriteLine($"private static {typeFullName}? {fieldName};");
            writer.WriteLine(
                $"{converter.GetAccessibilityString()} static {typeFullName} {converter.Name} => {fieldName} ?? ({fieldName} = new {typeFullName}()); "
            );
        }
        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
        ExecutionContext.AddSource($"MapperConverters.g.cs", stringStream.ToString());
    }

    private Dictionary<
        INamedTypeSymbol,
        (
            HashSet<(INamedTypeSymbol Type, string MethodName)> ToMethods,
            HashSet<(INamedTypeSymbol Type, string MethodName)> FromMethods
        )
    > GetMapTargetAndMethod(
        SemanticModel semanticModel,
        IEnumerable<ClassDeclarationSyntax> declaredClasses
    )
    {
        var mapMethodsByType = new Dictionary<
            INamedTypeSymbol,
            (
                HashSet<(INamedTypeSymbol Type, string MethodName)> ToMethods,
                HashSet<(INamedTypeSymbol Type, string MethodName)> FromMethods
            )
        >(SymbolEqualityComparer.Default);
        foreach (var declaredClass in declaredClasses)
        {
            var classSymbol = (INamedTypeSymbol)
                ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass)!;
            var attributeDatas = classSymbol
                .GetAttributes()
                .Where(x =>
                    x.AttributeClass!.ToString() is string name
                    && (
                        name == typeof(MapToAttribute).FullName
                        || name == typeof(MapFromAttribute).FullName
                    )
                );
            foreach (var attribute in attributeDatas)
            {
                var attributeName = attribute.AttributeClass!.GetFullName();
                if (attributeName == typeof(MapToAttribute).FullName)
                {
                    if (attribute.TryGetAttributeAndValues(out var datas) is false)
                        continue;
                    if (
                        datas.TryGetValue(nameof(MapToAttribute.TargetType), out var value) is false
                    )
                        continue;
                    datas.TryGetValue(nameof(MapToAttribute.MethodName), out var method);
                    var methodName = method.Value?.Value?.ToString();
                    var type = (INamedTypeSymbol)value.Value!.Value.Value!;
                    if (mapMethodsByType.TryGetValue(classSymbol, out var targets) is false)
                        targets = mapMethodsByType[classSymbol] = ([], []);
                    targets.ToMethods.Add(
                        (
                            type,
                            string.IsNullOrWhiteSpace(methodName)
                                ? $"MapTo{type.Name}"
                                : methodName!
                        )
                    );
                }
                else if (attributeName == typeof(MapFromAttribute).FullName)
                {
                    if (attribute.TryGetAttributeAndValues(out var datas) is false)
                        continue;
                    if (
                        datas.TryGetValue(nameof(MapToAttribute.TargetType), out var value) is false
                    )
                        continue;
                    datas.TryGetValue(nameof(MapToAttribute.MethodName), out var method);
                    var methodName = method.Value?.Value?.ToString();
                    var type = (INamedTypeSymbol)value.Value!.Value.Value!;
                    if (mapMethodsByType.TryGetValue(classSymbol, out var targets) is false)
                        targets = mapMethodsByType[type] = ([], []);
                    targets.FromMethods.Add(
                        (
                            type,
                            string.IsNullOrWhiteSpace(methodName)
                                ? $"MapFrom{type.Name}"
                                : methodName!
                        )
                    );
                }
            }
        }
        return mapMethodsByType;
    }
}
