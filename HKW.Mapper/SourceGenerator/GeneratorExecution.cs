using System.CodeDom.Compiler;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace HKW.HKWMapper.SourceGenerator;

internal partial class GeneratorExecution
{
    public static GeneratorExecution Load(GeneratorExecutionContext context)
    {
        return new() { ExecutionContext = context };
    }

    public GeneratorExecutionContext ExecutionContext { get; private set; }
    public Compilation Compilation { get; private set; } = null!;

    public INamedTypeSymbol IMapConverterType { get; private set; } = null!;

    public void Execute()
    {
        var compilation = LoadMapMethod();
        if (compilation is null)
            return;
        Compilation = compilation;
        IMapConverterType = Compilation.GetTypeByMetadataName(typeof(IMapConverter<,>).FullName)!;
        foreach (var compilationSyntaxTree in compilation.SyntaxTrees)
        {
            ParseSyntaxTree(compilationSyntaxTree);
        }
    }

    public Compilation? LoadMapMethod()
    {
        var compilation = ExecutionContext.Compilation;
        var mapMethods = new HashSet<string>();
        foreach (var compilationSyntaxTree in compilation.SyntaxTrees)
        {
            foreach (var mapMethod in GetMapMethods(compilationSyntaxTree))
                mapMethods.Add(mapMethod);
        }

        if (mapMethods.Count == 0)
            return null;
        var stringStream = GenerateMapMethods(mapMethods);

        // 将生成的代码添加到生成器中, 否则将无法正确识别创建的特性
        var attributeSourceText = SourceText.From(
            stringStream.ToString(),
            System.Text.Encoding.UTF8
        );
        ExecutionContext.AddSource($"MapAttributes.g.cs", attributeSourceText);
        var options = ((CSharpCompilation)ExecutionContext.Compilation).SyntaxTrees[0].Options;
        var attributeTree = CSharpSyntaxTree.ParseText(
            attributeSourceText,
            (CSharpParseOptions)options
        );
        return ExecutionContext.Compilation.AddSyntaxTrees(attributeTree);
    }

    public StringWriter GenerateMapMethods(HashSet<string> mapMethods)
    {
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;

        foreach (var mapMethod in mapMethods)
        {
            writer.WriteLine(
                @$"
/// <summary>
/// {mapMethod}PropertyAttribute
/// <para>This attribute is only used in <c>{mapMethod}</c></para>
/// </summary>
[AttributeUsage(AttributeTargets.Property, AllowMultiple = true)]
public sealed class {mapMethod}PropertyAttribute : Attribute
{{
    /// <inheritdoc/>
    public {mapMethod}PropertyAttribute(string PropertyName)
    {{
        this.PropertyName = PropertyName;
    }}

    /// <inheritdoc/>
    public {mapMethod}PropertyAttribute(Type ConverterType)
    {{
        this.ConverterType = ConverterType;
    }}

    /// <summary>
    /// PropertyName
    /// <para>Default is current property name</para>
    /// </summary>
    public string? PropertyName {{ get; set; }}

    /// <summary>
    /// PropertyAction
    /// <para>Default is <c>[source|traget].{{value}}</c></para>
    /// <para>e.g. <c>source.{{value}}.ToString()</c>, <c>int.Parse(source.{{value}})</c> etc.</para>
    /// </summary>
    public string? PropertyAction {{ get; set; }}

    /// <summary>
    /// ConverterType
    /// </summary>
    public Type? ConverterType {{ get; set; }}
}}"
            );
        }

        writer.Indent--;
        writer.WriteLine("}");
        return stringStream;
    }

    private HashSet<string> GetMapMethods(SyntaxTree compilationSyntaxTree)
    {
        var mapMethods = new HashSet<string>();
        var semanticModel = ExecutionContext.Compilation.GetSemanticModel(compilationSyntaxTree);
        var declaredClasses = compilationSyntaxTree
            .GetRoot()
            .DescendantNodesAndSelf()
            .OfType<ClassDeclarationSyntax>();
        foreach (var declaredClass in declaredClasses)
        {
            var classSymbol = (INamedTypeSymbol)
                ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass)!;
            var attributeDatas = classSymbol
                .GetAttributes()
                .Where(x =>
                    x.AttributeClass!.ToString() is string name
                    && (
                        name == typeof(MapToAttribute).FullName
                        || name == typeof(MapFromAttribute).FullName
                    )
                );
            foreach (var attribute in attributeDatas)
            {
                var attributeName = attribute.AttributeClass!.GetFullName();
                if (attributeName == typeof(MapToAttribute).FullName)
                {
                    if (attribute.TryGetAttributeAndValues(out var datas) is false)
                        continue;
                    if (
                        datas.TryGetValue(nameof(MapToAttribute.TargetType), out var value) is false
                    )
                        continue;
                    datas.TryGetValue(nameof(MapToAttribute.MethodName), out var methodData);
                    var methodName = methodData.Value?.Value?.ToString();
                    var type = (INamedTypeSymbol)value.Value!.Value.Value!;
                    if (string.IsNullOrWhiteSpace(methodName))
                        methodName = $"{classSymbol.Name}MapTo{type.Name}";
                    if (mapMethods.Add(methodName!) is false)
                    {
                        var errorDiagnostic = Diagnostic.Create(
                            Descriptors.SameMethodName,
                            attribute.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                                attribute.ApplicationSyntaxReference.Span
                            ),
                            methodName
                        );
                        ExecutionContext.ReportDiagnostic(errorDiagnostic);
                    }
                }
                else if (attributeName == typeof(MapFromAttribute).FullName)
                {
                    if (attribute.TryGetAttributeAndValues(out var datas) is false)
                        continue;
                    if (
                        datas.TryGetValue(nameof(MapToAttribute.TargetType), out var value) is false
                    )
                        continue;
                    datas.TryGetValue(nameof(MapToAttribute.MethodName), out var methodData);
                    var methodName = methodData.Value?.Value?.ToString();
                    var type = (INamedTypeSymbol)value.Value!.Value.Value!;
                    if (string.IsNullOrWhiteSpace(methodName))
                        methodName = $"{classSymbol.Name}MapFrom{type.Name}";
                    if (mapMethods.Add(methodName!) is false)
                    {
                        var errorDiagnostic = Diagnostic.Create(
                            Descriptors.SameMethodName,
                            classSymbol.Locations[0],
                            methodName
                        );
                        ExecutionContext.ReportDiagnostic(errorDiagnostic);
                    }
                }
            }
        }
        return mapMethods;
    }

    private void ParseSyntaxTree(SyntaxTree syntaxTree)
    {
        var semanticModel = Compilation.GetSemanticModel(syntaxTree);
        var declaredClasses = syntaxTree
            .GetRoot()
            .DescendantNodesAndSelf()
            .OfType<ClassDeclarationSyntax>();

        var mapMethodsByType = GetMapTargetAndMethod(semanticModel, declaredClasses);
        var converters = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        foreach (var map in mapMethodsByType)
        {
            GenerateMap(syntaxTree, converters, map);
        }

        if (converters.Count > 0)
        {
            GenerateComverter(syntaxTree, converters);
        }
    }

    private void GenerateMap(
        SyntaxTree syntaxTree,
        HashSet<INamedTypeSymbol> converters,
        KeyValuePair<
            INamedTypeSymbol,
            (HashSet<MapInfo> ToMethods, HashSet<MapInfo> FromMethods)
        > pair
    )
    {
        var usings = ((CompilationUnitSyntax)syntaxTree.GetRoot()).Usings;
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine(usings);
        writer.WriteLine("#pragma warning disable CS8604");
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("/// <summary>MapperExtensions</summary>");
        writer.WriteLine($"public static partial class MapperExtensions");
        writer.WriteLine("{");
        writer.Indent++;
        foreach (var target in pair.Value.ToMethods)
        {
            GenerateToMethod(converters, pair.Key, writer, target);
        }

        foreach (var target in pair.Value.FromMethods)
        {
            GenerateFromMethod(converters, pair.Key, writer, target);
        }

        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
        ExecutionContext.AddSource(
            $"{pair.Key.GetFullNameAndGeneric(true)}.Mapper.g.cs",
            stringStream.ToString()
        );
    }

    private void GenerateToMethod(
        HashSet<INamedTypeSymbol> converters,
        INamedTypeSymbol sourceType,
        IndentedTextWriter writer,
        MapInfo target
    )
    {
        var accessibility = sourceType.GetLowestAccessibility(target.Type);
        writer.WriteLine(
            $"{accessibility} static {target.Type.GetFullNameAndGeneric()} {target.MethodName}(this {sourceType.GetFullNameAndGeneric()} source, {target.Type.GetFullNameAndGeneric()} target)"
        );
        writer.WriteLine("{");
        writer.Indent++;
        var mapPropertyAttributeName = NativeUtils.GetMapPropertyAttributeName(
            sourceType,
            target.MethodName
        );
        var mapIgnorePropertyAttributeName = NativeUtils.GetMapIgnorePropertyAttributeName(
            sourceType,
            target.MethodName
        );
        foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
        {
            var attributes = property.GetAttributes();
            // 如果是静态属性,则跳过
            if (property.IsStatic)
                continue;
            // 如果是被忽略的属性,则跳过
            if (
                attributes.Any(x =>
                    x.AttributeClass?.GetFullName() == mapIgnorePropertyAttributeName
                    || x.AttributeClass?.GetFullName()
                        == typeof(MapIgnorePropertyAttribute).FullName
                )
            )
                continue;
            var attributeDatas = attributes.Where(x =>
                x.AttributeClass!.GetFullName() == mapPropertyAttributeName
            );
            // 如果没有特性,则直接使用同名属性
            if (attributeDatas.Any() is not true)
            {
                // 检查目标属性
                if (
                    CheckProperty(target, property, property.Name) is IPropertySymbol targetProperty
                )
                {
                    // 比较当前属性与目标属性的类型
                    if (
                        SymbolEqualityComparer.Default.Equals(targetProperty.Type, property.Type)
                        is false
                    )
                    {
                        var errorDiagnostic = Diagnostic.Create(
                            Descriptors.TargetPropertyTypeDifferent,
                            property.Locations[0],
                            targetProperty.ToString(),
                            targetProperty.Type.ToDisplayString(
                                SymbolDisplayFormat.FullyQualifiedFormat
                            ),
                            target.MethodName
                        );
                        ExecutionContext.ReportDiagnostic(errorDiagnostic);
                        continue;
                    }
                    writer.WriteLine($"target.{property.Name} = source.{property.Name};");
                }
                continue;
            }
            var targetPropertys = new HashSet<string>();
            foreach (var attributeData in attributeDatas)
            {
                var targetPropertyName = property.Name;
                string? propertyAction = null;
                INamedTypeSymbol? converterType = null;
                // 从特性获取数据
                GetDataFromAttribute(
                    converters,
                    targetPropertys,
                    attributeData,
                    ref targetPropertyName,
                    ref converterType,
                    out var attributeValues
                );
                // 设置属性行动
                if (
                    attributeValues.TryGetValue(
                        nameof(MapPropertyAttribute.PropertyAction),
                        out var actionData
                    )
                )
                {
                    var action = actionData.Value?.Value?.ToString();
                    if (string.IsNullOrWhiteSpace(action) is false)
                        propertyAction = action!.Replace("{value}", property.Name);
                }
                // 检查属性
                if (
                    CheckProperty(target, property, targetPropertyName)
                    is not IPropertySymbol targetProperty
                )
                    continue;
                if (propertyAction is not null)
                {
                    // 如果手动设置了行动, 则跳过类型检查
                    if (converterType is not null)
                    {
                        writer.WriteLine(
                            $"target.{targetPropertyName} = {converterType.Name}.{nameof(IMapConverter.Convert)}(source, {propertyAction});"
                        );
                    }
                    else
                    {
                        writer.WriteLine($"target.{targetPropertyName} = {propertyAction};");
                    }
                }
                else
                {
                    propertyAction = $"source.{property.Name}";
                    if (converterType is not null)
                    {
                        if (CheckConverter(property, targetProperty, attributeData, converterType))
                            writer.WriteLine(
                                $"target.{targetPropertyName} = {converterType.Name}.{nameof(IMapConverter.Convert)}(source, {propertyAction});"
                            );
                    }
                    else
                    {
                        // 比较当前属性与目标属性的类型
                        if (
                            SymbolEqualityComparer.Default.Equals(
                                targetProperty.Type,
                                property.Type
                            )
                            is false
                        )
                        {
                            var errorDiagnostic = Diagnostic.Create(
                                Descriptors.TargetPropertyTypeDifferentNoMethod,
                                attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                                    attributeData.ApplicationSyntaxReference.Span
                                ),
                                targetProperty.ToString(),
                                targetProperty.Type.ToDisplayString(
                                    SymbolDisplayFormat.FullyQualifiedFormat
                                )
                            );
                            ExecutionContext.ReportDiagnostic(errorDiagnostic);
                            continue;
                        }
                        writer.WriteLine($"target.{targetPropertyName} = {propertyAction};");
                    }
                }
            }
        }
        writer.WriteLine("return target;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    private void GenerateFromMethod(
        HashSet<INamedTypeSymbol> converters,
        INamedTypeSymbol sourceType,
        IndentedTextWriter writer,
        MapInfo target
    )
    {
        var accessibility = sourceType.GetLowestAccessibility(target.Type);
        writer.WriteLine(
            $"{accessibility} static {sourceType.GetFullNameAndGeneric()} {target.MethodName}(this {sourceType.GetFullNameAndGeneric()} source, {target.Type.GetFullNameAndGeneric()} target)"
        );
        writer.WriteLine("{");
        writer.Indent++;
        var mapPropertyAttributeName = NativeUtils.GetMapPropertyAttributeName(
            sourceType,
            target.MethodName
        );
        var mapIgnorePropertyAttributeName = NativeUtils.GetMapIgnorePropertyAttributeName(
            sourceType,
            target.MethodName
        );
        foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
        {
            // 如果是静态属性,则跳过
            if (property.IsStatic)
                continue;
            var attributes = property.GetAttributes();
            if (
                attributes.Any(x =>
                    x.AttributeClass?.GetFullName() == mapIgnorePropertyAttributeName
                    || x.AttributeClass?.GetFullName()
                        == typeof(MapIgnorePropertyAttribute).FullName
                )
            )
                continue;
            var attributeDatas = attributes.Where(x =>
                x.AttributeClass!.GetFullName() == mapPropertyAttributeName
            );
            // 如果没有特性,则直接使用同名属性
            if (attributeDatas.Any() is not true)
            {
                // 检查目标属性
                if (
                    CheckProperty(target, property, property.Name) is IPropertySymbol targetProperty
                )
                {
                    // 比较当前属性与目标属性的类型
                    if (
                        SymbolEqualityComparer.Default.Equals(targetProperty.Type, property.Type)
                        is false
                    )
                    {
                        var errorDiagnostic = Diagnostic.Create(
                            Descriptors.TargetPropertyTypeDifferent,
                            property.Locations[0],
                            targetProperty.ToString(),
                            targetProperty.Type.ToDisplayString(
                                SymbolDisplayFormat.FullyQualifiedFormat
                            ),
                            target.MethodName
                        );
                        ExecutionContext.ReportDiagnostic(errorDiagnostic);
                        continue;
                    }
                    writer.WriteLine($"target.{property.Name} = source.{property.Name};");
                }
                continue;
            }
            var targetPropertys = new HashSet<string>();
            foreach (var attributeData in attributeDatas)
            {
                var targetPropertyName = property.Name;
                string? propertyAction = null;
                INamedTypeSymbol? converterType = null;
                // 从特性获取信息
                GetDataFromAttribute(
                    converters,
                    targetPropertys,
                    attributeData,
                    ref targetPropertyName,
                    ref converterType,
                    out var attributeValues
                );
                // 检查属性
                if (
                    CheckProperty(target, property, targetPropertyName)
                    is not IPropertySymbol targetProperty
                )
                    continue;
                // 设置属性行动
                if (
                    attributeValues.TryGetValue(
                        nameof(MapPropertyAttribute.PropertyAction),
                        out var actionData
                    )
                )
                {
                    var action = actionData.Value?.Value?.ToString();
                    if (string.IsNullOrWhiteSpace(action) is false)
                        propertyAction = action!.Replace("{value}", targetPropertyName);
                }
                if (propertyAction is not null)
                {
                    // 如果手动设置了行动, 则跳过类型检查
                    if (converterType is not null)
                    {
                        writer.WriteLine(
                            $"source.{property.Name} = {converterType.Name}.{nameof(IMapConverter.ConvertBack)}(target, {propertyAction});"
                        );
                    }
                    else
                    {
                        writer.WriteLine($"source.{property.Name} = {propertyAction};");
                    }
                }
                else
                {
                    propertyAction = $"target.{targetPropertyName}";
                    if (converterType is not null)
                    {
                        if (CheckConverter(property, targetProperty, attributeData, converterType))
                            writer.WriteLine(
                                $"source.{property.Name} = {converterType.Name}.{nameof(IMapConverter.ConvertBack)}(target, {propertyAction});"
                            );
                    }
                    else
                    {
                        // 比较当前属性与目标属性的类型
                        if (
                            SymbolEqualityComparer.Default.Equals(
                                targetProperty.Type,
                                property.Type
                            )
                            is false
                        )
                        {
                            var errorDiagnostic = Diagnostic.Create(
                                Descriptors.TargetPropertyTypeDifferentNoMethod,
                                attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                                    attributeData.ApplicationSyntaxReference.Span
                                ),
                                targetProperty.ToString(),
                                targetProperty.Type.ToDisplayString(
                                    SymbolDisplayFormat.FullyQualifiedFormat
                                )
                            );
                            ExecutionContext.ReportDiagnostic(errorDiagnostic);
                            continue;
                        }
                        writer.WriteLine($"source.{property.Name} = {propertyAction};");
                    }
                }
            }
        }
        writer.WriteLine("return source;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    private IPropertySymbol? CheckProperty(
        MapInfo target,
        IPropertySymbol property,
        string? targetPropertyName
    )
    {
        // 目标属性不存在
        if (
            target.Type.GetMember<IPropertySymbol>(targetPropertyName!)
            is not IPropertySymbol targetProperty
        )
        {
            if (target.Scrutiny)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyNotExists,
                    property.Locations[0],
                    target.Type.GetFullNameAndGeneric() + "." + property.Name
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return null;
        }
        // 只读属性
        if (targetProperty.SetMethod is null)
        {
            if (target.Scrutiny)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyIsReadOnly,
                    property.Locations[0],
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return null;
        }
        // 静态属性
        if (targetProperty.IsStatic)
        {
            if (target.Scrutiny)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyIsStatic,
                    property.Locations[0],
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return null;
        }
        if (targetProperty.SetMethod.DeclaredAccessibility == Accessibility.Public)
            return targetProperty;
        // 可访问性为本地或保护本地
        if (
            (
                targetProperty.SetMethod.DeclaredAccessibility == Accessibility.Internal
                || targetProperty.SetMethod.DeclaredAccessibility
                    == Accessibility.ProtectedOrInternal
            )
        )
        {
            // 在主程序集
            if (
                SymbolEqualityComparer.Default.Equals(
                    targetProperty.SetMethod.ContainingAssembly,
                    Compilation.Assembly
                )
            )
                return targetProperty;
            if (target.Scrutiny)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyInsufficientAccessibility,
                    property.Locations[0],
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return null;
        }
        // 更低的可访问性
        if (targetProperty.SetMethod.DeclaredAccessibility < Accessibility.Internal)
        {
            if (target.Scrutiny)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyInsufficientAccessibility,
                    property.Locations[0],
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return null;
        }
        return targetProperty;
    }

    private bool CheckConverter(
        IPropertySymbol property,
        IPropertySymbol targetProperty,
        AttributeData attributeData,
        INamedTypeSymbol converterType
    )
    {
        var iconverter = converterType.Interfaces.First(x =>
            SymbolEqualityComparer.Default.Equals(x.OriginalDefinition, IMapConverterType)
        );
        var converterCurrentType = iconverter.TypeArguments[0];
        // 比较转换器当前属性与当前属性的类型
        if (SymbolEqualityComparer.Default.Equals(property.Type, converterCurrentType) is false)
        {
            var errorDiagnostic = Diagnostic.Create(
                Descriptors.ConverterCurrentTypeDifferentNoMethod,
                attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                    attributeData.ApplicationSyntaxReference.Span
                ),
                converterCurrentType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            );
            ExecutionContext.ReportDiagnostic(errorDiagnostic);
            return false;
        }
        var converterTargetType = iconverter.TypeArguments[1];
        // 比较转换器目标属性与目标属性的类型
        if (
            SymbolEqualityComparer.Default.Equals(targetProperty.Type, converterTargetType) is false
        )
        {
            var errorDiagnostic = Diagnostic.Create(
                Descriptors.ConverterTargetTypeDifferentNoMethod,
                attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                    attributeData.ApplicationSyntaxReference.Span
                ),
                converterTargetType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                targetProperty.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            );
            ExecutionContext.ReportDiagnostic(errorDiagnostic);
            return false;
        }
        return true;
    }

    private void GetDataFromAttribute(
        HashSet<INamedTypeSymbol> converters,
        HashSet<string> targetPropertys,
        AttributeData attributeData,
        ref string? targetPropertyName,
        ref INamedTypeSymbol? converterType,
        out Dictionary<string, TypeAndValue> attributeValues
    )
    {
        if (attributeData.TryGetAttributeAndValues(out attributeValues) is true)
        {
            if (
                attributeValues.TryGetValue(
                    nameof(MapPropertyAttribute.PropertyName),
                    out var nameData
                )
            )
            {
                var name = nameData.Value?.Value?.ToString();
                if (string.IsNullOrWhiteSpace(name) is false)
                    targetPropertyName = name;
            }
            if (
                attributeValues.TryGetValue(
                    nameof(MapPropertyAttribute.ConverterType),
                    out var converterData
                )
            )
            {
                converterType = converterData.Value?.Value as INamedTypeSymbol;
                if (converterType is not null)
                {
                    if (
                        converterType.Interfaces.Any(x =>
                            SymbolEqualityComparer.Default.Equals(
                                x.OriginalDefinition,
                                IMapConverterType
                            )
                        )
                        is false
                    )
                    {
                        var errorDiagnostic = Diagnostic.Create(
                            Descriptors.ConverterError,
                            attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                                attributeData.ApplicationSyntaxReference.Span
                            ),
                            converterType.Name
                        );
                        ExecutionContext.ReportDiagnostic(errorDiagnostic);
                    }
                    converters.Add(converterType);
                }
            }
            // 两个特性使用了相同的目标属性
            if (targetPropertys.Add(targetPropertyName!) is false)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.SameTargetName,
                    attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                        attributeData.ApplicationSyntaxReference.Span
                    ),
                    targetPropertyName
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
        }
    }

    private void GenerateComverter(SyntaxTree syntaxTree, HashSet<INamedTypeSymbol> converters)
    {
        var usings = ((CompilationUnitSyntax)syntaxTree.GetRoot()).Usings;
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine(usings);
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine($"public static partial class MapperExtensions");
        writer.WriteLine("{");
        writer.Indent++;
        foreach (var converter in converters)
        {
            var typeFullName = converter.GetFullName();
            var fieldName = $"_{converter.Name.FirstLetterToLower()}";
            writer.WriteLine($"private static {typeFullName}? {fieldName};");
            writer.WriteLine(
                $"{converter.GetAccessibilityString()} static {typeFullName} {converter.Name} => {fieldName} ?? ({fieldName} = new {typeFullName}()); "
            );
        }
        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
        ExecutionContext.AddSource($"MapperConverters.g.cs", stringStream.ToString());
    }

    private Dictionary<
        INamedTypeSymbol,
        (HashSet<MapInfo> ToMethods, HashSet<MapInfo> FromMethods)
    > GetMapTargetAndMethod(
        SemanticModel semanticModel,
        IEnumerable<ClassDeclarationSyntax> declaredClasses
    )
    {
        var mapMethodsByType = new Dictionary<
            INamedTypeSymbol,
            (HashSet<MapInfo> ToMethods, HashSet<MapInfo> FromMethods)
        >(SymbolEqualityComparer.Default);
        foreach (var declaredClass in declaredClasses)
        {
            var classSymbol = (INamedTypeSymbol)
                ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass)!;
            var attributeDatas = classSymbol
                .GetAttributes()
                .Where(x =>
                    x.AttributeClass!.ToString() is string name
                    && (
                        name == typeof(MapToAttribute).FullName
                        || name == typeof(MapFromAttribute).FullName
                    )
                );
            foreach (var attribute in attributeDatas)
            {
                var attributeName = attribute.AttributeClass!.GetFullName();
                if (attributeName == typeof(MapToAttribute).FullName)
                {
                    if (attribute.TryGetAttributeAndValues(out var datas) is false)
                        continue;
                    if (
                        datas.TryGetValue(nameof(MapToAttribute.TargetType), out var value) is false
                    )
                        continue;
                    datas.TryGetValue(nameof(MapToAttribute.MethodName), out var method);
                    datas.TryGetValue(nameof(MapToAttribute.ScrutinyMode), out var scrutiny);
                    var type = (INamedTypeSymbol)value.Value!.Value.Value!;
                    var methodName = method?.Value?.Value?.ToString() ?? $"MapTo{type.Name}";
                    if (mapMethodsByType.TryGetValue(classSymbol, out var targets) is false)
                        targets = mapMethodsByType[classSymbol] = ([], []);
                    targets.ToMethods.Add(new(type, methodName, scrutiny?.Value?.Value is true));
                }
                else if (attributeName == typeof(MapFromAttribute).FullName)
                {
                    if (attribute.TryGetAttributeAndValues(out var datas) is false)
                        continue;
                    if (
                        datas.TryGetValue(nameof(MapToAttribute.TargetType), out var value) is false
                    )
                        continue;
                    datas.TryGetValue(nameof(MapToAttribute.MethodName), out var method);
                    datas.TryGetValue(nameof(MapToAttribute.ScrutinyMode), out var scrutiny);
                    var type = (INamedTypeSymbol)value.Value!.Value.Value!;
                    var methodName = method?.Value?.Value?.ToString() ?? $"MapFrom{type.Name}";
                    if (mapMethodsByType.TryGetValue(classSymbol, out var targets) is false)
                        targets = mapMethodsByType[type] = ([], []);
                    targets.FromMethods.Add(new(type, methodName, scrutiny?.Value?.Value is true));
                }
            }
        }
        return mapMethodsByType;
    }
}
