using System.CodeDom.Compiler;
using HKW.SourceGeneratorUtils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace HKW.HKWMapper.SourceGenerator;

internal partial class GeneratorExecution
{
    public static GeneratorExecution Load(GeneratorExecutionContext context)
    {
        return new() { ExecutionContext = context };
    }

    public GeneratorExecutionContext ExecutionContext { get; private set; }
    public Compilation Compilation { get; private set; } = null!;

    public INamedTypeSymbol IMapConverterType { get; private set; } = null!;
    public INamedTypeSymbol MapConfigType { get; private set; } = null!;
    public Dictionary<INamedTypeSymbol, MapperConfigInfo> MapperConfigInfoByType
    {
        get;
        private set;
    } = null!;

    public HashSet<INamedTypeSymbol> Converters { get; private set; } = [];
    public HashSet<INamedTypeSymbol> Configs { get; private set; } = [];

    public void Execute()
    {
        var compilation = LoadMapMethod();
        if (compilation is null)
            return;
        Compilation = compilation;
        IMapConverterType = Compilation.GetTypeByMetadataName(typeof(IMapConverter<,>).FullName)!;
        MapConfigType = Compilation.GetTypeByMetadataName(typeof(MapperConfig<,>).FullName)!;

        MapperConfigInfoByType = GetMapperConfigInfos(ExecutionContext);
        foreach (var compilationSyntaxTree in compilation.SyntaxTrees)
        {
            ParseSyntaxTree(compilationSyntaxTree);
        }

        if (Converters.Count > 0)
        {
            GenerateComverter(Converters);
        }

        if (Configs.Count > 0)
        {
            GenerateConfig(Configs);
        }
    }

    public Compilation? LoadMapMethod()
    {
        var compilation = ExecutionContext.Compilation;
        var mapMethods = new HashSet<string>();
        foreach (var compilationSyntaxTree in compilation.SyntaxTrees)
        {
            foreach (var mapMethod in GetMapMethods(compilationSyntaxTree))
                mapMethods.Add(mapMethod);
        }

        if (mapMethods.Count == 0)
            return null;
        var stringStream = GenerateMapMethods(mapMethods);

        // 将生成的代码添加到生成器中, 否则将无法正确识别创建的特性
        var attributeSourceText = SourceText.From(
            stringStream.ToString(),
            System.Text.Encoding.UTF8
        );
        ExecutionContext.AddSource($"MapAttributes.g.cs", attributeSourceText);
        var options = ((CSharpCompilation)ExecutionContext.Compilation).SyntaxTrees[0].Options;
        var attributeTree = CSharpSyntaxTree.ParseText(
            attributeSourceText,
            (CSharpParseOptions)options
        );
        return ExecutionContext.Compilation.AddSyntaxTrees(attributeTree);
    }

    public StringWriter GenerateMapMethods(HashSet<string> mapMethods)
    {
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine("#pragma warning disable CS1591");
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;

        foreach (var mapMethod in mapMethods)
        {
            writer.WriteLine(
                @$"
/// <summary>
/// {mapMethod}PropertyAttribute
/// <para>This attribute is only used in <c>{mapMethod}</c></para>
/// </summary>
[AttributeUsage(AttributeTargets.Property)]
{CommonData.GeneratedCodeAttribute}
public sealed class {mapMethod}PropertyAttribute : Attribute
{{
    /// <inheritdoc/>
    public {mapMethod}PropertyAttribute(string PropertyName)
    {{
        this.PropertyName = PropertyName;
    }}

    /// <inheritdoc/>
    public {mapMethod}PropertyAttribute(Type ConverterType)
    {{
        this.ConverterType = ConverterType;
    }}

    /// <summary>
    /// PropertyName
    /// <para>Default is current property name</para>
    /// </summary>
    public string? PropertyName {{ get; set; }}

    /// <summary>
    /// ConverterType
    /// </summary>
    public Type? ConverterType {{ get; set; }}

    /// <summary>
    /// {nameof(MapPropertyAttribute.MapWhenRValueNotNullOrDefault)}
    /// </summary>
    public bool {nameof(MapPropertyAttribute.MapWhenRValueNotNullOrDefault)} {{ get; set; }}

    /// <summary>
    /// {nameof(MapPropertyAttribute.MapWhenLValueNullOrDefault)}
    /// </summary>
    public bool {nameof(MapPropertyAttribute.MapWhenLValueNullOrDefault)} {{ get; set; }}
}}"
            );
        }

        writer.Indent--;
        writer.WriteLine("}");
        return stringStream;
    }

    private void ParseSyntaxTree(SyntaxTree syntaxTree)
    {
        var semanticModel = Compilation.GetSemanticModel(syntaxTree);
        var declaredClasses = syntaxTree
            .GetRoot()
            .DescendantNodesAndSelf()
            .OfType<ClassDeclarationSyntax>();

        var mapMethodsByType = GetMapTargetAndMethod(semanticModel, declaredClasses);
        foreach (var pair in mapMethodsByType)
        {
            GenerateMap(syntaxTree, pair);
        }
    }

    private void GenerateMap(
        SyntaxTree syntaxTree,
        KeyValuePair<
            INamedTypeSymbol,
            (HashSet<MapInfo> ToMethods, HashSet<MapInfo> FromMethods)
        > pair
    )
    {
        var usings = ((CompilationUnitSyntax)syntaxTree.GetRoot()).Usings;
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine("#pragma warning disable CS1591");
        writer.WriteLine("#pragma warning disable CS8604");
        writer.WriteLine(usings);
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("/// <summary>MapperExtensions</summary>");
        writer.WriteLine($"public static partial class MapperExtensions");
        writer.WriteLine("{");
        writer.Indent++;
        foreach (var target in pair.Value.ToMethods)
        {
            GenerateToMethod(pair.Key, writer, target);
        }

        foreach (var target in pair.Value.FromMethods)
        {
            GenerateFromMethod(pair.Key, writer, target);
        }

        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
        ExecutionContext.AddSource(
            $"{pair.Key.GetFullNameAndGeneric(true)}.Mapper.g.cs",
            stringStream.ToString()
        );
    }

    private void GenerateToMethod(
        INamedTypeSymbol sourceType,
        IndentedTextWriter writer,
        MapInfo mapInfo
    )
    {
        var accessibility = sourceType.GetLowestAccessibility(mapInfo.TargetType);
        writer.WriteLine(CommonData.GeneratedCodeAttribute);
        writer.WriteLine(
            $"{accessibility} static {mapInfo.TargetType.GetFullNameAndGeneric()} {mapInfo.MethodName}(this {sourceType.GetFullNameAndGeneric()} source, {mapInfo.TargetType.GetFullNameAndGeneric()} target)"
        );
        writer.WriteLine("{");
        writer.Indent++;
        var mapPropertyAttributeName = NativeUtils.GetMapPropertyAttributeName(
            sourceType,
            mapInfo.MethodName
        );
        // 添加映射开始行动
        if (mapInfo.MapConfigType is not null)
        {
            writer.WriteLine(
                $"{mapInfo.MapConfigType.Name}.{nameof(MapperConfig<int, int>.BeginMapAction)}(source,target);"
            );
            Configs.Add(mapInfo.MapConfigType);
        }
        foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
        {
            GenerateToMethodProperty(writer, mapInfo, mapPropertyAttributeName, property);
        }
        // 添加映射结束行动
        if (mapInfo.MapConfigType is not null)
        {
            writer.WriteLine(
                $"{mapInfo.MapConfigType.Name}.{nameof(MapperConfig<int, int>.EndMapAction)}(source,target);"
            );
        }
        writer.WriteLine("return target;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    void GenerateToMethodProperty(
        IndentedTextWriter writer,
        MapInfo mapInfo,
        string mapPropertyAttributeName,
        IPropertySymbol property
    )
    {
        // 如果是静态属性,则跳过
        if (property.IsStatic)
            return;
        // 如果是索引器,则跳过
        if (property.IsIndexer)
            return;
        var attributes = property.GetAttributes();
        // 获取特性
        var attributeData = attributes.FirstOrDefault(x =>
            x.AttributeClass!.GetFullName() == mapPropertyAttributeName
        );

        // 如果这个属性在映射设置中有添加
        if (
            mapInfo.MapConfigType is not null
            && MapperConfigInfoByType.TryGetValue(mapInfo.MapConfigType, out var mapConfigInfo)
            && mapConfigInfo.AddedMapProperties.Contains(property.Name)
        )
        {
            writer.WriteLine(
                $"{mapInfo.MapConfigType.Name}.{nameof(MapperConfig<int, int>.GetMapAction)}(\"{property.Name}\")(source, target);"
            );
            if (attributeData is not null)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.MapHasBeenAdded,
                    attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                        attributeData.ApplicationSyntaxReference.Span
                    ),
                    mapInfo.MapConfigType.GetFullNameAndGeneric()
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return;
        }

        // 如果是被忽略的属性,则跳过
        if (
            attributes.Any(x =>
                x.AttributeClass?.GetFullName() == typeof(MapIgnorePropertyAttribute).FullName
            )
        )
            return;

        // 如果没有特性,则直接使用同名属性
        if (attributeData is null)
        {
            // 检查目标属性
            if (
                CheckProperty(mapInfo, property, property.Name)
                is not IPropertySymbol targetProperty
            )
                return;
            // 比较当前属性与目标属性的类型
            if (SymbolEqualityComparer.Default.Equals(targetProperty.Type, property.Type) is false)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyTypeDifferent,
                    property.Locations[0],
                    targetProperty.ToString(),
                    targetProperty.Type.GetFullNameAndGeneric(),
                    mapInfo.MethodName
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
                return;
            }
            writer.WriteLine($"target.{property.Name} = source.{property.Name};");
        }
        else
        {
            var targetPropertyName = property.Name;
            INamedTypeSymbol? converterType = null;
            // 从特性获取数据
            GetDataFromPropertyAttribute(
                attributeData,
                ref targetPropertyName,
                ref converterType,
                out var attributeParameters
            );
            // 检查属性
            if (
                CheckProperty(mapInfo, property, targetPropertyName)
                is not IPropertySymbol targetProperty
            )
                return;

            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenRValueNotNullOrDefault),
                    out var mapWhenR
                ) && mapWhenR.Value is true
            )
            {
                if (property.Type.IsValueType)
                    writer.WriteLine($"if(source.{property.Name} == default)");
                else
                    writer.WriteLine($"if(source.{property.Name} is not null)");
            }

            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenLValueNullOrDefault),
                    out var mapWhenL
                ) && mapWhenL.Value is true
            )
            {
                if (targetProperty.Type.IsValueType)
                    writer.WriteLine($"if(target.{targetPropertyName} == default)");
                else
                    writer.WriteLine($"if(target.{targetPropertyName} is null)");
            }

            if (converterType is not null)
            {
                if (CheckConverter(property, targetProperty, attributeData, converterType))
                    writer.WriteLine(
                        $"target.{targetPropertyName} = {converterType.Name}.{nameof(IMapConverter.Convert)}(source, source.{property.Name});"
                    );
            }
            else
            {
                // 比较当前属性与目标属性的类型
                if (
                    SymbolEqualityComparer.Default.Equals(targetProperty.Type, property.Type)
                    is false
                )
                {
                    var errorDiagnostic = Diagnostic.Create(
                        Descriptors.TargetPropertyTypeDifferentNoMethod,
                        attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                            attributeData.ApplicationSyntaxReference.Span
                        ),
                        targetProperty.ToString(),
                        targetProperty.Type.GetFullNameAndGeneric()
                    );
                    ExecutionContext.ReportDiagnostic(errorDiagnostic);
                    return;
                }
                writer.WriteLine($"target.{targetPropertyName} = source.{property.Name};");
            }
        }
    }

    private void GenerateFromMethod(
        INamedTypeSymbol sourceType,
        IndentedTextWriter writer,
        MapInfo mapInfo
    )
    {
        var accessibility = sourceType.GetLowestAccessibility(mapInfo.TargetType);
        writer.WriteLine(CommonData.GeneratedCodeAttribute);
        writer.WriteLine(
            $"{accessibility} static {sourceType.GetFullNameAndGeneric()} {mapInfo.MethodName}(this {sourceType.GetFullNameAndGeneric()} source, {mapInfo.TargetType.GetFullNameAndGeneric()} target)"
        );
        writer.WriteLine("{");
        writer.Indent++;
        var mapPropertyAttributeName = NativeUtils.GetMapPropertyAttributeName(
            sourceType,
            mapInfo.MethodName
        );
        // 添加映射开始行动
        if (mapInfo.MapConfigType is not null)
        {
            writer.WriteLine(
                $"{mapInfo.MapConfigType.Name}.{nameof(MapperConfig<int, int>.BeginMapAction)}(source,target);"
            );
            Configs.Add(mapInfo.MapConfigType);
        }
        foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
        {
            GenerateFromMethodProperty(writer, mapInfo, mapPropertyAttributeName, property);
        }
        // 添加映射结束行动
        if (mapInfo.MapConfigType is not null)
        {
            writer.WriteLine(
                $"{mapInfo.MapConfigType.Name}.{nameof(MapperConfig<int, int>.EndMapAction)}(source,target);"
            );
        }
        writer.WriteLine("return source;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    private void GenerateFromMethodProperty(
        IndentedTextWriter writer,
        MapInfo mapInfo,
        string mapPropertyAttributeName,
        IPropertySymbol property
    )
    {
        // 如果是静态属性,则跳过
        if (property.IsStatic)
            return;
        // 如果是索引器,则跳过
        if (property.IsIndexer)
            return;
        var attributes = property.GetAttributes();

        // 获取特性
        var attributeData = attributes.FirstOrDefault(x =>
            x.AttributeClass!.GetFullName() == mapPropertyAttributeName
        );
        // 如果这个属性在映射设置中有添加
        if (
            mapInfo.MapConfigType is not null
            && MapperConfigInfoByType.TryGetValue(mapInfo.MapConfigType, out var mapConfigInfo)
            && mapConfigInfo.AddedMapProperties.Contains(property.Name)
        )
        {
            writer.WriteLine(
                $"{mapInfo.MapConfigType.Name}.{nameof(MapperConfig<int, int>.GetMapAction)}(\"{property.Name}\")(source, target);"
            );
            if (attributeData is not null)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.MapHasBeenAdded,
                    attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                        attributeData.ApplicationSyntaxReference.Span
                    ),
                    mapInfo.MapConfigType.GetFullNameAndGeneric()
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return;
        }
        // 如果是被忽略的属性,则跳过
        if (
            attributes.Any(x =>
                x.AttributeClass?.GetFullName() == typeof(MapIgnorePropertyAttribute).FullName
            )
        )
            return;

        // 如果没有特性,则直接使用同名属性
        if (attributeData is null)
        {
            // 检查目标属性
            if (
                CheckProperty(mapInfo, property, property.Name)
                is not IPropertySymbol targetProperty
            )
                return;
            // 比较当前属性与目标属性的类型
            if (SymbolEqualityComparer.Default.Equals(targetProperty.Type, property.Type) is false)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyTypeDifferent,
                    property.Locations[0],
                    targetProperty.ToString(),
                    targetProperty.Type.GetFullNameAndGeneric(),
                    mapInfo.MethodName
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
                return;
            }
            writer.WriteLine($"source.{property.Name} = target.{property.Name};");
            return;
        }
        else
        {
            var targetPropertyName = property.Name;
            INamedTypeSymbol? converterType = null;
            // 从特性获取信息
            GetDataFromPropertyAttribute(
                attributeData,
                ref targetPropertyName,
                ref converterType,
                out var attributeParameters
            );
            // 检查属性
            if (
                CheckProperty(mapInfo, property, targetPropertyName)
                is not IPropertySymbol targetProperty
            )
                return;
            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenRValueNotNullOrDefault),
                    out var mapWhenR
                ) && mapWhenR.Value is true
            )
            {
                if (targetProperty.Type.IsValueType)
                    writer.WriteLine($"if(target.{targetPropertyName} == default)");
                else
                    writer.WriteLine($"if(target.{targetPropertyName} is not null)");
            }

            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenLValueNullOrDefault),
                    out var mapWhenL
                ) && mapWhenL.Value is true
            )
            {
                if (property.Type.IsValueType)
                    writer.WriteLine($"if(source.{property.Name} == default)");
                else
                    writer.WriteLine($"if(source.{property.Name} is null)");
            }

            if (converterType is not null)
            {
                if (CheckConverter(property, targetProperty, attributeData, converterType))
                    writer.WriteLine(
                        $"source.{property.Name} = {converterType.Name}.{nameof(IMapConverter.ConvertBack)}(target, target.{targetPropertyName});"
                    );
            }
            else
            {
                // 比较当前属性与目标属性的类型
                if (
                    SymbolEqualityComparer.Default.Equals(targetProperty.Type, property.Type)
                    is false
                )
                {
                    var errorDiagnostic = Diagnostic.Create(
                        Descriptors.TargetPropertyTypeDifferentNoMethod,
                        attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                            attributeData.ApplicationSyntaxReference.Span
                        ),
                        targetProperty.ToString(),
                        targetProperty.Type.GetFullNameAndGeneric()
                    );
                    ExecutionContext.ReportDiagnostic(errorDiagnostic);
                    return;
                }
                writer.WriteLine($"source.{property.Name} = target.{targetPropertyName};");
            }
        }
    }

    private void GenerateComverter(HashSet<INamedTypeSymbol> converters)
    {
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine("#pragma warning disable CS1591");
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine($"public static partial class MapperExtensions");
        writer.WriteLine("{");
        writer.Indent++;
        foreach (var converter in converters)
        {
            var typeFullName = converter.GetFullName();
            var fieldName = $"_{converter.Name.FirstLetterToLower()}";
            writer.WriteLine(CommonData.GeneratedCodeAttribute);
            writer.WriteLine($"private static {typeFullName}? {fieldName};");
            writer.WriteLine(CommonData.GeneratedCodeAttribute);
            writer.WriteLine(
                $"{converter.GetAccessibilityString()} static {typeFullName} {converter.Name} => {fieldName} ?? ({fieldName} = new {typeFullName}()); "
            );
        }
        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
        ExecutionContext.AddSource($"MapperConverters.g.cs", stringStream.ToString());
    }

    private void GenerateConfig(HashSet<INamedTypeSymbol> configs)
    {
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine("#pragma warning disable CS1591");
        writer.WriteLine();
        writer.WriteLine($"namespace HKW.HKWMapper");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine($"public static partial class MapperExtensions");
        writer.WriteLine("{");
        writer.Indent++;
        foreach (var config in configs)
        {
            var typeFullName = config.GetFullName();
            var fieldName = $"_{config.Name.FirstLetterToLower()}";
            writer.WriteLine(CommonData.GeneratedCodeAttribute);
            writer.WriteLine($"private static {typeFullName}? {fieldName};");
            writer.WriteLine(CommonData.GeneratedCodeAttribute);
            writer.WriteLine(
                $"{config.GetAccessibilityString()} static {typeFullName} {config.Name} => {fieldName} ?? ({fieldName} = ({typeFullName})new {typeFullName}().Frozen()); "
            );
        }
        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
        ExecutionContext.AddSource($"MapperConfigs.g.cs", stringStream.ToString());
    }
}
