using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Text;
using HKW.SourceGeneratorUtils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace HKW.HKWMapper.SourceGenerator;

internal class GenerateMappers
{
    public static GenerateMappers Execute(
        GeneratorExecutionContext context,
        Compilation compilation
    )
    {
        var x = new GenerateMappers() { ExecutionContext = context, Compilation = compilation };
        x.Execute();
        return x;
    }

    public GeneratorExecutionContext ExecutionContext { get; private set; }

    public Compilation Compilation { get; private set; } = null!;
    public Dictionary<INamedTypeSymbol, HashSet<string>> MapperConfigInfoByType
    {
        get;
        private set;
    } = null!;
    public HashSet<INamedTypeSymbol> Converters { get; private set; } = [];
    public HashSet<INamedTypeSymbol> Configs { get; private set; } = [];
    public INamedTypeSymbol IMapConverterType { get; private set; } = null!;
    public INamedTypeSymbol MapConfigType { get; private set; } = null!;

    public void Execute()
    {
        IMapConverterType = Compilation.GetTypeByMetadataName(typeof(IMapConverter<,>).FullName)!;
        MapConfigType = Compilation.GetTypeByMetadataName(typeof(MapperConfig<,>).FullName)!;
        MapperConfigInfoByType = GetMapperConfigInfos(ExecutionContext);

        foreach (var syntaxTree in Compilation.SyntaxTrees)
        {
            ParseSyntaxTree(syntaxTree);
        }
    }

    private void ParseSyntaxTree(SyntaxTree syntaxTree)
    {
        var semanticModel = Compilation.GetSemanticModel(syntaxTree);
        var declaredClasses = syntaxTree
            .GetRoot()
            .DescendantNodesAndSelf()
            .OfType<ClassDeclarationSyntax>();

        var mapMethodsByType = GetMapTargetAndMethod(semanticModel, declaredClasses);
        GenerateMethods(syntaxTree, mapMethodsByType);
    }

    private void GenerateMethods(
        SyntaxTree syntaxTree,
        Dictionary<INamedTypeSymbol, MapperMethods> mapMethodsByType
    )
    {
        var usings = ((CompilationUnitSyntax)syntaxTree.GetRoot()).Usings;
        foreach (var pair in mapMethodsByType)
        {
            var stringStream = new StringWriter();
            var writer = new IndentedTextWriter(stringStream, "\t");
            writer.WriteLine("// <auto-generated>");
            writer.WriteLine("#nullable enable");
            writer.WriteLine("#pragma warning disable CS1591");
            writer.WriteLine("#pragma warning disable CS8604");
            writer.WriteLine(usings);
            writer.WriteLine();
            writer.WriteLine($"namespace {pair.Key.ContainingNamespace}");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine("/// <summary>MapperExtensions</summary>");
            writer.WriteLine($"public static partial class MapperExtensions");
            writer.WriteLine("{");
            writer.Indent++;
            foreach (var target in pair.Value.ToMethods)
            {
                GenerateToMethod(pair.Key, writer, target);
            }

            foreach (var target in pair.Value.FromMethods)
            {
                GenerateFromMethod(pair.Key, writer, target);
            }

            writer.Indent--;
            writer.WriteLine("}");
            writer.Indent--;
            writer.WriteLine("}");
            ExecutionContext.AddSource(
                $"{pair.Key.GetNameAndGeneric(true)}.Mapper.g.cs",
                stringStream.ToString()
            );
        }
    }

    private void GenerateToMethod(
        INamedTypeSymbol sourceType,
        IndentedTextWriter writer,
        MapInfo mapInfo
    )
    {
        var accessibility = sourceType.GetLowestAccessibility(mapInfo.TargetType);
        writer.WriteLine(CommonData.GeneratedCodeAttribute);
        writer.WriteLine(
            $"{accessibility} static {mapInfo.TargetType.GetFullNameAndGeneric()} {mapInfo.MethodName}(this {sourceType.GetFullNameAndGeneric()} source, {mapInfo.TargetType.GetFullNameAndGeneric()} target)"
        );
        writer.WriteLine("{");
        writer.Indent++;
        var mapPropertyAttributeName = NativeUtils.GetMapPropertyAttributeName(
            sourceType,
            mapInfo.MethodName
        );
        // 添加映射开始行动
        if (mapInfo.MapConfigType is not null)
        {
            writer.WriteLine(
                $"{mapInfo.MapConfigType.GetUnderlineFullName()}.{nameof(MapperConfig<int, int>.BeginMapAction)}(source,target);"
            );
            Configs.Add(mapInfo.MapConfigType);
        }
        foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
        {
            GenerateToMethodProperty(writer, mapInfo, mapPropertyAttributeName, property);
        }
        // 添加映射结束行动
        if (mapInfo.MapConfigType is not null)
        {
            writer.WriteLine(
                $"{mapInfo.MapConfigType.GetUnderlineFullName()}.{nameof(MapperConfig<int, int>.EndMapAction)}(source,target);"
            );
        }
        writer.WriteLine("return target;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    void GenerateToMethodProperty(
        IndentedTextWriter writer,
        MapInfo mapInfo,
        string mapPropertyAttributeName,
        IPropertySymbol property
    )
    {
        // 如果是静态属性,则跳过
        if (property.IsStatic)
            return;
        // 如果是索引器,则跳过
        if (property.IsIndexer)
            return;
        var attributes = property.GetAttributes();
        // 获取特性
        var attributeData = attributes.FirstOrDefault(x =>
            x.AttributeClass!.GetFullName() == mapPropertyAttributeName
        );

        // 如果这个属性在映射设置中有添加
        if (
            mapInfo.MapConfigType is not null
            && MapperConfigInfoByType.TryGetValue(mapInfo.MapConfigType, out var mapConfigInfo)
            && mapConfigInfo.Contains(property.Name)
        )
        {
            writer.WriteLine(
                $"{mapInfo.MapConfigType.GetUnderlineFullName()}.{nameof(MapperConfig<int, int>.GetMapAction)}(\"{property.Name}\")(source, target);"
            );
            if (attributeData is not null)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.MapHasBeenAdded,
                    attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                        attributeData.ApplicationSyntaxReference.Span
                    ),
                    mapInfo.MapConfigType.GetFullNameAndGeneric()
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return;
        }

        // 如果是被忽略的属性,则跳过
        if (
            attributes.Any(x =>
                x.AttributeClass?.GetFullName() == typeof(MapIgnorePropertyAttribute).FullName
            )
        )
            return;

        // 如果没有特性,则直接使用同名属性
        if (attributeData is null)
        {
            // 检查目标属性
            if (
                CheckProperty(mapInfo, property, property.Name)
                is not IPropertySymbol targetProperty
            )
                return;
            // 比较当前属性与目标属性的类型
            if (SymbolEqualityComparer.Default.Equals(targetProperty.Type, property.Type) is false)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyTypeDifferent,
                    property.Locations[0],
                    targetProperty.ToString(),
                    targetProperty.Type.GetFullNameAndGeneric(),
                    mapInfo.MethodName
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
                return;
            }
            writer.WriteLine($"target.{property.Name} = source.{property.Name};");
        }
        else
        {
            var targetPropertyName = property.Name;
            INamedTypeSymbol? converterType = null;
            // 从特性获取数据
            GetDataFromPropertyAttribute(
                attributeData,
                ref targetPropertyName,
                ref converterType,
                out var attributeParameters
            );
            // 检查属性
            if (
                CheckProperty(mapInfo, property, targetPropertyName)
                is not IPropertySymbol targetProperty
            )
                return;

            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenRValueNotNullOrDefault),
                    out var mapWhenR
                ) && mapWhenR.Value is true
            )
            {
                if (property.Type.IsValueType)
                    writer.WriteLine($"if(source.{property.Name} == default)");
                else
                    writer.WriteLine($"if(source.{property.Name} is not null)");
            }

            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenLValueNullOrDefault),
                    out var mapWhenL
                ) && mapWhenL.Value is true
            )
            {
                if (targetProperty.Type.IsValueType)
                    writer.WriteLine($"if(target.{targetPropertyName} == default)");
                else
                    writer.WriteLine($"if(target.{targetPropertyName} is null)");
            }

            if (converterType is not null)
            {
                if (CheckConverter(property, targetProperty, attributeData, converterType))
                    writer.WriteLine(
                        $"target.{targetPropertyName} = {converterType.GetUnderlineFullName()}.{nameof(IMapConverter.Convert)}(source, source.{property.Name});"
                    );
            }
            else
            {
                // 比较当前属性与目标属性的类型
                if (
                    SymbolEqualityComparer.Default.Equals(targetProperty.Type, property.Type)
                    is false
                )
                {
                    var errorDiagnostic = Diagnostic.Create(
                        Descriptors.TargetPropertyTypeDifferentNoMethod,
                        attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                            attributeData.ApplicationSyntaxReference.Span
                        ),
                        targetProperty.ToString(),
                        targetProperty.Type.GetFullNameAndGeneric()
                    );
                    ExecutionContext.ReportDiagnostic(errorDiagnostic);
                    return;
                }
                writer.WriteLine($"target.{targetPropertyName} = source.{property.Name};");
            }
        }
    }

    private void GenerateFromMethod(
        INamedTypeSymbol sourceType,
        IndentedTextWriter writer,
        MapInfo mapInfo
    )
    {
        var accessibility = sourceType.GetLowestAccessibility(mapInfo.TargetType);
        writer.WriteLine(CommonData.GeneratedCodeAttribute);
        writer.WriteLine(
            $"{accessibility} static {sourceType.GetFullNameAndGeneric()} {mapInfo.MethodName}(this {sourceType.GetFullNameAndGeneric()} source, {mapInfo.TargetType.GetFullNameAndGeneric()} target)"
        );
        writer.WriteLine("{");
        writer.Indent++;
        var mapPropertyAttributeName = NativeUtils.GetMapPropertyAttributeName(
            sourceType,
            mapInfo.MethodName
        );
        // 添加映射开始行动
        if (mapInfo.MapConfigType is not null)
        {
            writer.WriteLine(
                $"{mapInfo.MapConfigType.GetUnderlineFullName()}.{nameof(MapperConfig<int, int>.BeginMapAction)}(source,target);"
            );
            Configs.Add(mapInfo.MapConfigType);
        }
        foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
        {
            GenerateFromMethodProperty(writer, mapInfo, mapPropertyAttributeName, property);
        }
        // 添加映射结束行动
        if (mapInfo.MapConfigType is not null)
        {
            writer.WriteLine(
                $"{mapInfo.MapConfigType.GetUnderlineFullName()}.{nameof(MapperConfig<int, int>.EndMapAction)}(source,target);"
            );
        }
        writer.WriteLine("return source;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
    }

    private void GenerateFromMethodProperty(
        IndentedTextWriter writer,
        MapInfo mapInfo,
        string mapPropertyAttributeName,
        IPropertySymbol property
    )
    {
        // 如果是静态属性,则跳过
        if (property.IsStatic)
            return;
        // 如果是索引器,则跳过
        if (property.IsIndexer)
            return;
        var attributes = property.GetAttributes();

        // 获取特性
        var attributeData = attributes.FirstOrDefault(x =>
            x.AttributeClass!.GetFullName() == mapPropertyAttributeName
        );
        // 如果这个属性在映射设置中有添加
        if (
            mapInfo.MapConfigType is not null
            && MapperConfigInfoByType.TryGetValue(mapInfo.MapConfigType, out var mapConfigInfo)
            && mapConfigInfo.Contains(property.Name)
        )
        {
            writer.WriteLine(
                $"{mapInfo.MapConfigType.GetUnderlineFullName()}.{nameof(MapperConfig<int, int>.GetMapAction)}(\"{property.Name}\")(source, target);"
            );
            if (attributeData is not null)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.MapHasBeenAdded,
                    attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                        attributeData.ApplicationSyntaxReference.Span
                    ),
                    mapInfo.MapConfigType.GetFullNameAndGeneric()
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return;
        }
        // 如果是被忽略的属性,则跳过
        if (
            attributes.Any(x =>
                x.AttributeClass?.GetFullName() == typeof(MapIgnorePropertyAttribute).FullName
            )
        )
            return;

        // 如果没有特性,则直接使用同名属性
        if (attributeData is null)
        {
            // 检查目标属性
            if (
                CheckProperty(mapInfo, property, property.Name)
                is not IPropertySymbol targetProperty
            )
                return;
            // 比较当前属性与目标属性的类型
            if (SymbolEqualityComparer.Default.Equals(targetProperty.Type, property.Type) is false)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyTypeDifferent,
                    property.Locations[0],
                    targetProperty.ToString(),
                    targetProperty.Type.GetFullNameAndGeneric(),
                    mapInfo.MethodName
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
                return;
            }
            writer.WriteLine($"source.{property.Name} = target.{property.Name};");
            return;
        }
        else
        {
            var targetPropertyName = property.Name;
            INamedTypeSymbol? converterType = null;
            // 从特性获取信息
            GetDataFromPropertyAttribute(
                attributeData,
                ref targetPropertyName,
                ref converterType,
                out var attributeParameters
            );
            // 检查属性
            if (
                CheckProperty(mapInfo, property, targetPropertyName)
                is not IPropertySymbol targetProperty
            )
                return;
            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenRValueNotNullOrDefault),
                    out var mapWhenR
                ) && mapWhenR.Value is true
            )
            {
                if (targetProperty.Type.IsValueType)
                    writer.WriteLine($"if(target.{targetPropertyName} == default)");
                else
                    writer.WriteLine($"if(target.{targetPropertyName} is not null)");
            }

            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenLValueNullOrDefault),
                    out var mapWhenL
                ) && mapWhenL.Value is true
            )
            {
                if (property.Type.IsValueType)
                    writer.WriteLine($"if(source.{property.Name} == default)");
                else
                    writer.WriteLine($"if(source.{property.Name} is null)");
            }

            if (converterType is not null)
            {
                if (CheckConverter(property, targetProperty, attributeData, converterType))
                    writer.WriteLine(
                        $"source.{property.Name} = {converterType.GetUnderlineFullName()}.{nameof(IMapConverter.ConvertBack)}(target, target.{targetPropertyName});"
                    );
            }
            else
            {
                // 比较当前属性与目标属性的类型
                if (
                    SymbolEqualityComparer.Default.Equals(targetProperty.Type, property.Type)
                    is false
                )
                {
                    var errorDiagnostic = Diagnostic.Create(
                        Descriptors.TargetPropertyTypeDifferentNoMethod,
                        attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                            attributeData.ApplicationSyntaxReference.Span
                        ),
                        targetProperty.ToString(),
                        targetProperty.Type.GetFullNameAndGeneric()
                    );
                    ExecutionContext.ReportDiagnostic(errorDiagnostic);
                    return;
                }
                writer.WriteLine($"source.{property.Name} = target.{targetPropertyName};");
            }
        }
    }

    private Dictionary<INamedTypeSymbol, HashSet<string>> GetMapperConfigInfos(
        GeneratorExecutionContext context
    )
    {
        var mapperConfigInfoByType = new Dictionary<INamedTypeSymbol, HashSet<string>>(
            SymbolEqualityComparer.Default
        );
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            return mapperConfigInfoByType;
        foreach (var classDeclaration in receiver.CandidateClasses)
        {
            var semanticModel = Compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
            if (
                SymbolEqualityComparer.Default.Equals(
                    classSymbol?.BaseType?.OriginalDefinition,
                    MapConfigType
                )
                is false
            )
                continue;
            var mapConfigInfo = new HashSet<string>();
            mapperConfigInfoByType.Add(classSymbol!, mapConfigInfo);
            var ctor = classDeclaration
                .Members.OfType<ConstructorDeclarationSyntax>()
                .FirstOrDefault(x => x.ParameterList.Parameters.Count == 0);

            if (ctor is null)
                continue;
            foreach (var invocation in ctor.DescendantNodes().OfType<InvocationExpressionSyntax>())
            {
                if (
                    invocation.Expression is not IdentifierNameSyntax identifier
                    || identifier.Identifier.Text != nameof(MapperConfig<int, int>.AddMap)
                )
                {
                    continue;
                }
                if (
                    invocation.ArgumentList.Arguments[0].Expression
                    is not SimpleLambdaExpressionSyntax lambdaExpression
                )
                {
                    continue;
                }
                var memberName = string.Empty;
                if (lambdaExpression.Body is MemberAccessExpressionSyntax body)
                {
                    memberName = body.Name.ToString();
                }
                if (lambdaExpression.Body is PostfixUnaryExpressionSyntax postfix)
                {
                    if (postfix.Operand is not MemberAccessExpressionSyntax member)
                        continue;
                    memberName = member.Name.ToString();
                }
                if (
                    string.IsNullOrWhiteSpace(memberName) is false
                    && mapConfigInfo.Add(memberName) is false
                )
                {
                    var errorDiagnostic = Diagnostic.Create(
                        Descriptors.SameMapPropertyConfig,
                        lambdaExpression.Body.GetLocation(),
                        memberName
                    );
                    ExecutionContext.ReportDiagnostic(errorDiagnostic);
                }
            }
        }
        return mapperConfigInfoByType;
    }

    private IPropertySymbol? CheckProperty(
        MapInfo target,
        IPropertySymbol property,
        string? targetPropertyName
    )
    {
        // 目标属性不存在
        if (
            target.TargetType.GetMember<IPropertySymbol>(targetPropertyName!)
            is not IPropertySymbol targetProperty
        )
        {
            if (target.ScrutinyMode)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyNotExists,
                    property.Locations[0],
                    target.TargetType.GetFullNameAndGeneric() + "." + property.Name
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return null;
        }
        // 只读属性
        if (targetProperty.SetMethod is null)
        {
            if (target.ScrutinyMode)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyIsReadOnly,
                    property.Locations[0],
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return null;
        }
        // 静态属性
        if (targetProperty.IsStatic)
        {
            if (target.ScrutinyMode)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyIsStatic,
                    property.Locations[0],
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return null;
        }
        if (targetProperty.SetMethod.DeclaredAccessibility == Accessibility.Public)
            return targetProperty;
        // 可访问性为本地或保护本地
        if (
            (
                targetProperty.SetMethod.DeclaredAccessibility == Accessibility.Internal
                || targetProperty.SetMethod.DeclaredAccessibility
                    == Accessibility.ProtectedOrInternal
            )
        )
        {
            // 在主程序集
            if (
                SymbolEqualityComparer.Default.Equals(
                    targetProperty.SetMethod.ContainingAssembly,
                    Compilation.Assembly
                )
            )
                return targetProperty;
            if (target.ScrutinyMode)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyInsufficientAccessibility,
                    property.Locations[0],
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return null;
        }
        // 更低的可访问性
        if (targetProperty.SetMethod.DeclaredAccessibility < Accessibility.Internal)
        {
            if (target.ScrutinyMode)
            {
                var errorDiagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyInsufficientAccessibility,
                    property.Locations[0],
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(errorDiagnostic);
            }
            return null;
        }
        return targetProperty;
    }

    private bool CheckConverter(
        IPropertySymbol property,
        IPropertySymbol targetProperty,
        AttributeData attributeData,
        INamedTypeSymbol converterType
    )
    {
        var iconverter = converterType.Interfaces.First(x =>
            SymbolEqualityComparer.Default.Equals(x.OriginalDefinition, IMapConverterType)
        );
        var converterCurrentType = iconverter.TypeArguments[0];
        // 比较转换器当前属性与当前属性的类型
        if (SymbolEqualityComparer.Default.Equals(property.Type, converterCurrentType) is false)
        {
            var errorDiagnostic = Diagnostic.Create(
                Descriptors.ConverterCurrentTypeDifferentNoMethod,
                attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                    attributeData.ApplicationSyntaxReference.Span
                ),
                converterCurrentType.GetFullNameAndGeneric(),
                property.Type.GetFullNameAndGeneric()
            );
            ExecutionContext.ReportDiagnostic(errorDiagnostic);
            return false;
        }
        var converterTargetType = iconverter.TypeArguments[1];
        // 比较转换器目标属性与目标属性的类型
        if (
            SymbolEqualityComparer.Default.Equals(targetProperty.Type, converterTargetType) is false
        )
        {
            var errorDiagnostic = Diagnostic.Create(
                Descriptors.ConverterTargetTypeDifferentNoMethod,
                attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                    attributeData.ApplicationSyntaxReference.Span
                ),
                converterTargetType.GetFullNameAndGeneric(),
                targetProperty.Type.GetFullNameAndGeneric()
            );
            ExecutionContext.ReportDiagnostic(errorDiagnostic);
            return false;
        }
        return true;
    }

    private void GetDataFromPropertyAttribute(
        AttributeData attributeData,
        ref string? targetPropertyName,
        ref INamedTypeSymbol? converterType,
        out Dictionary<string, AttributeParameterValue> parameters
    )
    {
        parameters = attributeData.GetAttributeParameters();
        if (parameters.Count == 0)
            return;

        if (parameters.TryGetValue(nameof(MapPropertyAttribute.PropertyName), out var nameData))
        {
            var name = nameData.Value?.ToString();
            if (string.IsNullOrWhiteSpace(name) is false)
                targetPropertyName = name;
        }
        if (
            parameters.TryGetValue(
                nameof(MapPropertyAttribute.ConverterType),
                out var converterData
            )
        )
        {
            converterType = converterData.Value as INamedTypeSymbol;
            if (converterType is not null)
            {
                if (
                    converterType.Interfaces.Any(x =>
                        SymbolEqualityComparer.Default.Equals(
                            x.OriginalDefinition,
                            IMapConverterType
                        )
                    )
                    is false
                )
                {
                    var errorDiagnostic = Diagnostic.Create(
                        Descriptors.ConverterError,
                        attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                            attributeData.ApplicationSyntaxReference.Span
                        ),
                        converterType.Name
                    );
                    ExecutionContext.ReportDiagnostic(errorDiagnostic);
                }
                Converters.Add(converterType);
            }
        }
    }

    private Dictionary<INamedTypeSymbol, MapperMethods> GetMapTargetAndMethod(
        SemanticModel semanticModel,
        IEnumerable<ClassDeclarationSyntax> declaredClasses
    )
    {
        var mapMethodsByType = new Dictionary<INamedTypeSymbol, MapperMethods>(
            SymbolEqualityComparer.Default
        );
        foreach (var declaredClass in declaredClasses)
        {
            var classSymbol = (INamedTypeSymbol)
                ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass)!;
            var attributeDatas = classSymbol
                .GetAttributes()
                .Where(x =>
                    x.AttributeClass!.ToString() is string name
                    && (
                        name == typeof(MapToAttribute).FullName
                        || name == typeof(MapFromAttribute).FullName
                    )
                );
            foreach (var attribute in attributeDatas)
            {
                var attributeName = attribute.AttributeClass!.GetFullName();
                if (attributeName == typeof(MapToAttribute).FullName)
                {
                    var parameters = attribute.GetAttributeParameters();
                    if (parameters.Count == 0)
                        continue;
                    if (
                        parameters.TryGetValue(nameof(MapToAttribute.TargetType), out var value)
                        is false
                    )
                        continue;
                    parameters.TryGetValue(nameof(MapToAttribute.TargetName), out var targetData);
                    parameters.TryGetValue(nameof(MapToAttribute.ScrutinyMode), out var scrutiny);
                    parameters.TryGetValue(nameof(MapToAttribute.MapperConfig), out var mapConfig);
                    var targetType = (INamedTypeSymbol)value.Value!;
                    var targetName = targetData?.Value?.ToString() ?? targetType.Name;
                    var methodName = $"MapTo{targetName}";
                    var mapConfigType = mapConfig?.Value as INamedTypeSymbol;
                    if (mapMethodsByType.TryGetValue(classSymbol, out var targets) is false)
                        targets = mapMethodsByType[classSymbol] = new([], []);
                    mapConfigType = CheckMapConfig(
                        classSymbol,
                        attribute,
                        targetType,
                        mapConfigType
                    );
                    targets.ToMethods.Add(
                        new(targetType, methodName, scrutiny?.Value is true, mapConfigType)
                    );
                }
                else if (attributeName == typeof(MapFromAttribute).FullName)
                {
                    var parameters = attribute.GetAttributeParameters();
                    if (parameters.Count == 0)
                        continue;
                    if (
                        parameters.TryGetValue(nameof(MapToAttribute.TargetType), out var value)
                        is false
                    )
                        continue;
                    parameters.TryGetValue(nameof(MapToAttribute.TargetName), out var targetData);
                    parameters.TryGetValue(nameof(MapToAttribute.ScrutinyMode), out var scrutiny);
                    parameters.TryGetValue(nameof(MapToAttribute.MapperConfig), out var mapConfig);
                    var targetType = (INamedTypeSymbol)value.Value!;
                    var mapConfigType = mapConfig?.Value as INamedTypeSymbol;
                    var targetName = targetData?.Value?.ToString() ?? targetType.Name;
                    var methodName = $"MapFrom{targetName}";
                    if (mapMethodsByType.TryGetValue(classSymbol, out var targets) is false)
                        targets = mapMethodsByType[classSymbol] = new([], []);
                    mapConfigType = CheckMapConfig(
                        classSymbol,
                        attribute,
                        targetType,
                        mapConfigType
                    );
                    targets.FromMethods.Add(
                        new(targetType, methodName, scrutiny?.Value is true, mapConfigType)
                    );
                }
            }
        }
        return mapMethodsByType;
    }

    private INamedTypeSymbol? CheckMapConfig(
        INamedTypeSymbol classSymbol,
        AttributeData attribute,
        INamedTypeSymbol targetType,
        INamedTypeSymbol? mapConfigType
    )
    {
        if (
            SymbolEqualityComparer.Default.Equals(
                mapConfigType?.BaseType?.OriginalDefinition,
                MapConfigType
            )
        )
        {
            if (mapConfigType?.BaseType is INamedTypeSymbol baseType)
            {
                var configSourceType = baseType.TypeArguments[0];
                var configTargetType = baseType.TypeArguments[1];
                // 检查IMapConfig的类型
                if (SymbolEqualityComparer.Default.Equals(classSymbol, configSourceType))
                {
                    if (SymbolEqualityComparer.Default.Equals(targetType, configTargetType))
                    {
                        return mapConfigType;
                    }
                    var errorDiagnostic = Diagnostic.Create(
                        Descriptors.MapConfigTargetTypeDifferent,
                        attribute.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                            attribute.ApplicationSyntaxReference.Span
                        ),
                        configTargetType.GetFullNameAndGeneric(),
                        targetType.GetFullNameAndGeneric()
                    );
                    ExecutionContext.ReportDiagnostic(errorDiagnostic);
                }
                else
                {
                    var errorDiagnostic = Diagnostic.Create(
                        Descriptors.MapConfigSourceTypeDifferent,
                        attribute.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                            attribute.ApplicationSyntaxReference.Span
                        ),
                        configTargetType.GetFullNameAndGeneric(),
                        classSymbol.GetFullNameAndGeneric()
                    );
                    ExecutionContext.ReportDiagnostic(errorDiagnostic);
                }
            }
        }
        return null;
    }
}

internal record struct MapMethodAndAttributeName(string MethodName, string AttributeName);

internal record struct MapperMethods(HashSet<MapInfo> ToMethods, HashSet<MapInfo> FromMethods);
