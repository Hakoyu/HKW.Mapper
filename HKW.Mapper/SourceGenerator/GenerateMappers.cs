using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Text;
using HKW.SourceGeneratorUtils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace HKW.HKWMapper.SourceGenerator;

internal class GenerateMappers
{
    public static GenerateMappers Execute(
        GeneratorExecutionContext context,
        Compilation compilation
    )
    {
        var x = new GenerateMappers() { ExecutionContext = context, Compilation = compilation };
        x.Execute();
        return x;
    }

    public GeneratorExecutionContext ExecutionContext { get; private set; }

    public Compilation Compilation { get; private set; } = null!;

    /// <summary>
    /// (ObjectType, (memberName, isAsync))
    /// </summary>
    public Dictionary<INamedTypeSymbol, Dictionary<string, bool>> MapperConfigInfoByType
    {
        get;
        private set;
    } = null!;
    public INamedTypeSymbol MapConverterType { get; private set; } = null!;
    public INamedTypeSymbol MapConfigType { get; private set; } = null!;

    public void Execute()
    {
        MapConverterType = Compilation.GetTypeByMetadataName(typeof(MapConverter<,>).FullName)!;
        MapConfigType = Compilation.GetTypeByMetadataName(typeof(MapperConfig<,>).FullName)!;
        MapperConfigInfoByType = GetMapperConfigInfos(ExecutionContext);

        foreach (var syntaxTree in Compilation.SyntaxTrees)
        {
            ParseSyntaxTree(syntaxTree);
        }
    }

    private void ParseSyntaxTree(SyntaxTree syntaxTree)
    {
        var semanticModel = Compilation.GetSemanticModel(syntaxTree);
        var declaredClasses = syntaxTree
            .GetRoot()
            .DescendantNodesAndSelf()
            .OfType<ClassDeclarationSyntax>();

        var mapMethodsByType = GetMapTargetAndMethod(semanticModel, declaredClasses);
        GenerateMethods(syntaxTree, mapMethodsByType);
    }

    private void GenerateMethods(
        SyntaxTree syntaxTree,
        Dictionary<INamedTypeSymbol, MapperMethods> mapMethodsByType
    )
    {
        var usings = ((CompilationUnitSyntax)syntaxTree.GetRoot()).Usings;
        foreach (var pair in mapMethodsByType)
        {
            var stringStream = new StringWriter();
            var writer = new IndentedTextWriter(stringStream, "\t");
            writer.WriteLine("// <auto-generated>");
            writer.WriteLine("#nullable enable");
            writer.WriteLine("#pragma warning disable CS1591");
            writer.WriteLine("#pragma warning disable CS8604");
            writer.WriteLine(usings);
            writer.WriteLine();
            writer.WriteLine($"namespace {pair.Key.ContainingNamespace}");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine("/// <summary>MapperExtensions</summary>");
            writer.WriteLine($"public static partial class MapperExtensions");
            writer.WriteLine("{");
            writer.Indent++;

            foreach (var mapInfo in pair.Value.ToMethodInfos)
            {
                if (mapInfo.InvokeState.HasFlag(MapMethodInvokeState.Sync))
                    GenerateMethod(pair.Key, writer, mapInfo);
                mapInfo.IndexByConverter.Clear();
                if (mapInfo.InvokeState.HasFlag(MapMethodInvokeState.Async))
                    GenerateAsyncMethod(pair.Key, writer, mapInfo);
            }

            foreach (var mapInfo in pair.Value.FromMethodInfos)
            {
                if (mapInfo.InvokeState.HasFlag(MapMethodInvokeState.Sync))
                    GenerateMethod(pair.Key, writer, mapInfo);
                mapInfo.IndexByConverter.Clear();
                if (mapInfo.InvokeState.HasFlag(MapMethodInvokeState.Async))
                    GenerateAsyncMethod(pair.Key, writer, mapInfo);
            }

            writer.Indent--;
            writer.WriteLine("}");
            writer.Indent--;
            writer.WriteLine("}");
            ExecutionContext.AddSource(
                $"{pair.Key.GetNameAndGeneric(true)}.Mapper.g.cs",
                stringStream.ToString()
            );
        }
    }

    private void GenerateMethod(
        INamedTypeSymbol sourceType,
        IndentedTextWriter writer,
        MapInfo mapInfo
    )
    {
        var accessibility = sourceType.GetLowestAccessibility(mapInfo.TargetType);
        writer.WriteLine(CommonData.GeneratedCodeAttribute);
        writer.WriteLine(
            $"{accessibility} static {(mapInfo.IsMapTo ? mapInfo.TargetType.GetFullNameAndGeneric() : sourceType.GetFullNameAndGeneric())} {mapInfo.MethodName}(this {sourceType.GetFullNameAndGeneric()} source, {mapInfo.TargetType.GetFullNameAndGeneric()} target)"
        );
        writer.WriteLine("{");
        writer.Indent++;
        if (mapInfo.ConfigType is not null)
        {
            writer.WriteLine(
                $"var config = HKW.HKWMapper.MapperCache.GetConfig<{mapInfo.ConfigType.GetFullName()}>();"
            );
        }
        GenerateBeginMapAction(writer, mapInfo);
        var sourceByTarget = new Dictionary<IPropertySymbol, IPropertySymbol>(
            SymbolEqualityComparer.Default
        );
        if (mapInfo.IsMapTo)
        {
            foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
            {
                var targetProperty = GenerateToMethodProperty(
                    writer,
                    mapInfo,
                    property,
                    out var attributeData
                );

                CheckSameTargetProperty(sourceByTarget, property, targetProperty, attributeData);
            }
        }
        else
        {
            foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
            {
                var targetProperty = GenerateFromMethodProperty(
                    writer,
                    mapInfo,
                    property,
                    out var attributeData
                );
                CheckSameTargetProperty(sourceByTarget, property, targetProperty, attributeData);
            }
        }
        GenerateEndMapAction(writer, mapInfo);
        writer.WriteLine(mapInfo.IsMapTo ? "return target;" : "return source;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();

        void CheckSameTargetProperty(
            Dictionary<IPropertySymbol, IPropertySymbol> sourceByTarget,
            IPropertySymbol property,
            IPropertySymbol? targetProperty,
            AttributeData? attributeData
        )
        {
            if (targetProperty is null)
                return;
            if (sourceByTarget.TryGetValue(targetProperty, out var sourceProperty) is false)
            {
                sourceByTarget.Add(targetProperty, property);
            }
            else
            {
                var diagnostic = Diagnostic.Create(
                    Descriptors.SameMapTargetProperty,
                    attributeData?.ApplicationSyntaxReference?.SyntaxTree.GetLocation(
                        attributeData.ApplicationSyntaxReference.Span
                    ),
                    sourceProperty.ToString(),
                    property.ToString(),
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(diagnostic);
            }
        }
    }

    private IPropertySymbol? GenerateToMethodProperty(
        IndentedTextWriter writer,
        MapInfo mapInfo,
        IPropertySymbol property,
        out AttributeData? attributeData
    )
    {
        attributeData = null;
        // 如果是静态属性,则跳过
        if (property.IsStatic)
            return null;
        // 如果是索引器,则跳过
        if (property.IsIndexer)
            return null;
        var attributes = property.GetAttributes();
        // 获取特性
        attributeData = attributes.FirstOrDefault(x =>
            x.AttributeClass!.GetFullName() == mapInfo.PropertyAttributeFullName
        );

        // 如果这个属性在映射设置中有添加
        if (CheckMapConfigInfo(mapInfo, property, attributeData) is string addMap)
        {
            writer.WriteLine(addMap);
            return null;
        }

        // 如果是被忽略的属性,则跳过
        if (
            attributes.Any(x =>
                x.AttributeClass?.GetFullName() == typeof(MapIgnorePropertyAttribute).FullName
            )
        )
            return null;

        // 如果没有特性,则直接使用同名属性
        if (attributeData is null)
        {
            // 获取目标属性
            if (
                GetTargetProperty(mapInfo, property, property.Name)
                is not IPropertySymbol targetProperty
            )
                return null;

            GenerateStandardProperty(writer, mapInfo, property, targetProperty);
            return targetProperty;
        }
        else
        {
            var targetPropertyName = property.Name;
            // 从特性获取数据
            var attributeParameters = GetDataFromPropertyAttribute(
                attributeData,
                ref targetPropertyName,
                out var converterType
            );
            // 获取目标属性
            if (
                GetTargetProperty(mapInfo, property, targetPropertyName)
                is not IPropertySymbol targetProperty
            )
                return null;

            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenRValueNotNullOrDefault),
                    out var mapWhenR
                ) && mapWhenR.Value is true
            )
            {
                if (property.Type.IsValueType)
                    writer.WriteLine($"if(source.{property.Name} == default)");
                else
                    writer.WriteLine($"if(source.{property.Name} is not null)");
            }

            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenLValueNullOrDefault),
                    out var mapWhenL
                ) && mapWhenL.Value is true
            )
            {
                if (targetProperty.Type.IsValueType)
                    writer.WriteLine($"if(target.{targetPropertyName} == default)");
                else
                    writer.WriteLine($"if(target.{targetPropertyName} is null)");
            }

            if (converterType is not null)
            {
                if (
                    CheckConverter(
                        property,
                        targetProperty,
                        attributeData,
                        converterType,
                        out var isAsync
                    )
                )
                {
                    var converterName = GetConverterName(writer, mapInfo, converterType);
                    if (isAsync)
                    {
                        writer.WriteLine(
                            $"target.{targetPropertyName} = {converterName}.{nameof(MapConverter<int, int>.Convert)}(source, source.{property.Name}).Result;"
                        );
                    }
                    else
                    {
                        writer.WriteLine(
                            $"target.{targetPropertyName} = {converterName}.{nameof(MapConverter<int, int>.Convert)}(source, source.{property.Name});"
                        );
                    }
                }
            }
            else
            {
                GenerateStandardProperty(writer, mapInfo, property, targetProperty);
            }
            return targetProperty;
        }

        void GenerateStandardProperty(
            IndentedTextWriter writer,
            MapInfo mapInfo,
            IPropertySymbol property,
            IPropertySymbol targetProperty
        )
        {
            // 比较当前属性与目标属性的类型
            if (SymbolEqualityComparer.Default.Equals(targetProperty.Type, property.Type))
            {
                writer.WriteLine($"target.{targetProperty.Name} = source.{property.Name};");
            }
            else
            {
                // 如果是Task类型
                var taskResultType = property.Type.GetTaskResult();
                if (SymbolEqualityComparer.Default.Equals(targetProperty.Type, taskResultType))
                {
                    writer.WriteLine(
                        $"target.{targetProperty.Name} = source.{property.Name}.Result;"
                    );
                }
                else
                {
                    var diagnostic = Diagnostic.Create(
                        Descriptors.TargetPropertyTypeDifferent,
                        property.Locations[0],
                        targetProperty.ToString(),
                        targetProperty.Type.GetFullNameAndGeneric(),
                        mapInfo.MethodName
                    );
                    ExecutionContext.ReportDiagnostic(diagnostic);
                }
            }
        }
    }

    private static string GetConverterName(
        IndentedTextWriter writer,
        MapInfo mapInfo,
        INamedTypeSymbol converterType
    )
    {
        if (mapInfo.IndexByConverter.TryGetValue(converterType, out var index) is false)
        {
            index = mapInfo.IndexByConverter[converterType] = mapInfo.IndexByConverter.Count;
            writer.WriteLine(
                $"var converter{index} = HKW.HKWMapper.MapperCache.GetConverter<{converterType.GetFullName()}>();"
            );
        }
        return $"converter{index}";
    }

    private IPropertySymbol? GenerateFromMethodProperty(
        IndentedTextWriter writer,
        MapInfo mapInfo,
        IPropertySymbol property,
        out AttributeData? attributeData
    )
    {
        attributeData = null;
        // 如果是静态属性,则跳过
        if (property.IsStatic)
            return null;
        // 如果是索引器,则跳过
        if (property.IsIndexer)
            return null;
        var attributes = property.GetAttributes();

        // 获取特性
        attributeData = attributes.FirstOrDefault(x =>
            x.AttributeClass!.GetFullName() == mapInfo.PropertyAttributeFullName
        );
        // 如果这个属性在映射设置中有添加
        if (CheckMapConfigInfo(mapInfo, property, attributeData) is string addMap)
        {
            writer.WriteLine(addMap);
            return null;
        }

        // 如果是被忽略的属性,则跳过
        if (
            attributes.Any(x =>
                x.AttributeClass?.GetFullName() == typeof(MapIgnorePropertyAttribute).FullName
            )
        )
            return null;

        // 如果没有特性,则直接使用同名属性
        if (attributeData is null)
        {
            // 检查目标属性
            if (
                GetTargetProperty(mapInfo, property, property.Name)
                is not IPropertySymbol targetProperty
            )
                return null;

            GenerateStandardProperty(writer, mapInfo, property, targetProperty);
            return targetProperty;
        }
        else
        {
            var targetPropertyName = property.Name;
            // 从特性获取信息
            var attributeParameters = GetDataFromPropertyAttribute(
                attributeData,
                ref targetPropertyName,
                out var converterType
            );
            // 获取目标属性
            if (
                GetTargetProperty(mapInfo, property, targetPropertyName)
                is not IPropertySymbol targetProperty
            )
                return null;
            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenRValueNotNullOrDefault),
                    out var mapWhenR
                ) && mapWhenR.Value is true
            )
            {
                if (targetProperty.Type.IsValueType)
                    writer.WriteLine($"if(target.{targetPropertyName} == default)");
                else
                    writer.WriteLine($"if(target.{targetPropertyName} is not null)");
            }

            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenLValueNullOrDefault),
                    out var mapWhenL
                ) && mapWhenL.Value is true
            )
            {
                if (property.Type.IsValueType)
                    writer.WriteLine($"if(source.{property.Name} == default)");
                else
                    writer.WriteLine($"if(source.{property.Name} is null)");
            }

            if (converterType is not null)
            {
                if (
                    CheckConverter(
                        property,
                        targetProperty,
                        attributeData,
                        converterType,
                        out var isAsync
                    )
                )
                {
                    var converterName = GetConverterName(writer, mapInfo, converterType);
                    if (isAsync)
                    {
                        writer.WriteLine(
                            $"source.{property.Name} = {converterName}.{nameof(MapConverter<int, int>.ConvertBack)}(target, target.{targetPropertyName}).Result;"
                        );
                    }
                    else
                    {
                        writer.WriteLine(
                            $"source.{property.Name} = {converterName}.{nameof(MapConverter<int, int>.ConvertBack)}(target, target.{targetPropertyName});"
                        );
                    }
                }
            }
            else
            {
                GenerateStandardProperty(writer, mapInfo, property, targetProperty);
            }
            return targetProperty;
        }

        void GenerateStandardProperty(
            IndentedTextWriter writer,
            MapInfo mapInfo,
            IPropertySymbol property,
            IPropertySymbol targetProperty
        )
        {
            // 比较当前属性与目标属性的类型
            if (SymbolEqualityComparer.Default.Equals(property.Type, targetProperty.Type))
            {
                writer.WriteLine($"source.{property.Name} = target.{targetProperty.Name};");
            }
            else
            {
                // 如果是Task类型
                var taskResultType = targetProperty.Type.GetTaskResult();
                if (SymbolEqualityComparer.Default.Equals(property.Type, taskResultType))
                {
                    writer.WriteLine(
                        $"source.{property.Name} = target.{targetProperty.Name}.Result;"
                    );
                }
                else
                {
                    var diagnostic = Diagnostic.Create(
                        Descriptors.TargetPropertyTypeDifferent,
                        property.Locations[0],
                        targetProperty.ToString(),
                        targetProperty.Type.GetFullNameAndGeneric(),
                        mapInfo.MethodName
                    );
                    ExecutionContext.ReportDiagnostic(diagnostic);
                }
            }
        }
    }

    #region Async
    private void GenerateAsyncMethod(
        INamedTypeSymbol sourceType,
        IndentedTextWriter writer,
        MapInfo mapInfo
    )
    {
        var accessibility = sourceType.GetLowestAccessibility(mapInfo.TargetType);
        writer.WriteLine(CommonData.GeneratedCodeAttribute);
        writer.WriteLine(
            $"{accessibility} static async Task<{(mapInfo.IsMapTo ? mapInfo.TargetType.GetFullNameAndGeneric() : sourceType.GetFullNameAndGeneric())}> {mapInfo.MethodName}Async(this {sourceType.GetFullNameAndGeneric()} source, {mapInfo.TargetType.GetFullNameAndGeneric()} target)"
        );
        writer.WriteLine("{");
        writer.Indent++;
        if (mapInfo.ConfigType is not null)
        {
            writer.WriteLine(
                $"var config = HKW.HKWMapper.MapperCache.GetConfig<{mapInfo.ConfigType.GetFullName()}>();"
            );
        }
        GenerateBeginMapAction(writer, mapInfo);
        var sourceByTarget = new Dictionary<IPropertySymbol, IPropertySymbol>(
            SymbolEqualityComparer.Default
        );
        if (mapInfo.IsMapTo)
        {
            foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
            {
                var targetProperty = GenerateAsyncToMethodProperty(
                    writer,
                    mapInfo,
                    property,
                    out var attributeData
                );
                CheckSameTargetProperty(sourceByTarget, property, targetProperty, attributeData);
            }
        }
        else
        {
            foreach (var property in sourceType.GetMembers().OfType<IPropertySymbol>())
            {
                var targetProperty = GenerateAsyncFromMethodProperty(
                    writer,
                    mapInfo,
                    property,
                    out var attributeData
                );
                CheckSameTargetProperty(sourceByTarget, property, targetProperty, attributeData);
            }
        }
        GenerateEndMapAction(writer, mapInfo);

        if (mapInfo.IsAsync is false)
        {
            var diagnostic = Diagnostic.Create(
                Descriptors.MapAsyncTaskDoesNotExist,
                mapInfo.Attribute.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                    mapInfo.Attribute.ApplicationSyntaxReference.Span
                )
            );
            ExecutionContext.ReportDiagnostic(diagnostic);
        }
        writer.WriteLine(mapInfo.IsMapTo ? "return target;" : "return source;");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();

        void CheckSameTargetProperty(
            Dictionary<IPropertySymbol, IPropertySymbol> sourceByTarget,
            IPropertySymbol property,
            IPropertySymbol? targetProperty,
            AttributeData? attributeData
        )
        {
            if (targetProperty is null)
                return;
            if (sourceByTarget.TryGetValue(targetProperty, out var sourceProperty) is false)
            {
                sourceByTarget.Add(targetProperty, property);
            }
            else
            {
                var diagnostic = Diagnostic.Create(
                    Descriptors.SameMapTargetProperty,
                    attributeData?.ApplicationSyntaxReference?.SyntaxTree.GetLocation(
                        attributeData.ApplicationSyntaxReference.Span
                    ),
                    sourceProperty.ToString(),
                    property.ToString(),
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(diagnostic);
            }
        }
    }

    private IPropertySymbol? GenerateAsyncToMethodProperty(
        IndentedTextWriter writer,
        MapInfo mapInfo,
        IPropertySymbol property,
        out AttributeData? attributeData
    )
    {
        attributeData = null;
        // 如果是静态属性,则跳过
        if (property.IsStatic)
            return null;
        // 如果是索引器,则跳过
        if (property.IsIndexer)
            return null;
        var attributes = property.GetAttributes();
        // 获取特性
        attributeData = attributes.FirstOrDefault(x =>
            x.AttributeClass!.GetFullName() == mapInfo.PropertyAttributeFullName
        );

        // 如果这个属性在映射设置中有添加
        if (CheckAsyncMapConfigInfo(mapInfo, property, attributeData) is string addMap)
        {
            writer.WriteLine(addMap);
            return null;
        }

        // 如果是被忽略的属性,则跳过
        if (
            attributes.Any(x =>
                x.AttributeClass?.GetFullName() == typeof(MapIgnorePropertyAttribute).FullName
            )
        )
            return null;

        // 如果没有特性,则直接使用同名属性
        if (attributeData is null)
        {
            // 获取目标属性
            if (
                GetTargetProperty(mapInfo, property, property.Name)
                is not IPropertySymbol targetProperty
            )
                return null;
            GenerateStandardProperty(writer, mapInfo, property, targetProperty);
            return targetProperty;
        }
        else
        {
            var targetPropertyName = property.Name;
            // 从特性获取数据
            var attributeParameters = GetDataFromPropertyAttribute(
                attributeData,
                ref targetPropertyName,
                out var converterType
            );
            // 检查属性
            if (
                GetTargetProperty(mapInfo, property, targetPropertyName)
                is not IPropertySymbol targetProperty
            )
                return null;

            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenRValueNotNullOrDefault),
                    out var mapWhenR
                ) && mapWhenR.Value is true
            )
            {
                if (property.Type.IsValueType)
                    writer.WriteLine($"if(source.{property.Name} == default)");
                else
                    writer.WriteLine($"if(source.{property.Name} is not null)");
            }

            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenLValueNullOrDefault),
                    out var mapWhenL
                ) && mapWhenL.Value is true
            )
            {
                if (targetProperty.Type.IsValueType)
                    writer.WriteLine($"if(target.{targetPropertyName} == default)");
                else
                    writer.WriteLine($"if(target.{targetPropertyName} is null)");
            }

            if (converterType is not null)
            {
                if (
                    CheckConverter(
                        property,
                        targetProperty,
                        attributeData,
                        converterType,
                        out var isAsync
                    )
                )
                {
                    var converterName = GetConverterName(writer, mapInfo, converterType);
                    if (isAsync)
                    {
                        mapInfo.IsAsync = true;
                        writer.WriteLine(
                            $"target.{targetPropertyName} = await {converterName}.{nameof(MapConverter<int, int>.Convert)}(source, source.{property.Name});"
                        );
                    }
                    else
                    {
                        writer.WriteLine(
                            $"target.{targetPropertyName} = {converterName}.{nameof(MapConverter<int, int>.Convert)}(source, source.{property.Name});"
                        );
                    }
                }
            }
            else
            {
                GenerateStandardProperty(writer, mapInfo, property, targetProperty);
            }
            return targetProperty;
        }

        void GenerateStandardProperty(
            IndentedTextWriter writer,
            MapInfo mapInfo,
            IPropertySymbol property,
            IPropertySymbol targetProperty
        )
        {
            // 比较当前属性与目标属性的类型
            if (SymbolEqualityComparer.Default.Equals(targetProperty.Type, property.Type))
            {
                writer.WriteLine($"target.{targetProperty.Name} = source.{property.Name};");
            }
            else
            {
                // 如果是Task类型
                var taskResultType = property.Type.GetTaskResult();
                if (SymbolEqualityComparer.Default.Equals(targetProperty.Type, taskResultType))
                {
                    mapInfo.IsAsync = true;
                    writer.WriteLine(
                        $"target.{targetProperty.Name} = await source.{property.Name};"
                    );
                }
                else
                {
                    var diagnostic = Diagnostic.Create(
                        Descriptors.TargetPropertyTypeDifferent,
                        property.Locations[0],
                        targetProperty.ToString(),
                        targetProperty.Type.GetFullNameAndGeneric(),
                        mapInfo.MethodName
                    );
                    ExecutionContext.ReportDiagnostic(diagnostic);
                }
            }
        }
    }

    private IPropertySymbol? GenerateAsyncFromMethodProperty(
        IndentedTextWriter writer,
        MapInfo mapInfo,
        IPropertySymbol property,
        out AttributeData? attributeData
    )
    {
        attributeData = null;
        // 如果是静态属性,则跳过
        if (property.IsStatic)
            return null;
        // 如果是索引器,则跳过
        if (property.IsIndexer)
            return null;
        var attributes = property.GetAttributes();

        // 获取特性
        attributeData = attributes.FirstOrDefault(x =>
            x.AttributeClass!.GetFullName() == mapInfo.PropertyAttributeFullName
        );
        // 如果这个属性在映射设置中有添加
        if (CheckAsyncMapConfigInfo(mapInfo, property, attributeData) is string addMap)
        {
            writer.WriteLine(addMap);
            return null;
        }

        // 如果是被忽略的属性,则跳过
        if (
            attributes.Any(x =>
                x.AttributeClass?.GetFullName() == typeof(MapIgnorePropertyAttribute).FullName
            )
        )
            return null;

        // 如果没有特性,则直接使用同名属性
        if (attributeData is null)
        {
            // 检查目标属性
            if (
                GetTargetProperty(mapInfo, property, property.Name)
                is not IPropertySymbol targetProperty
            )
                return null;

            GenerateStandardProperty(writer, mapInfo, property, targetProperty);
            return targetProperty;
        }
        else
        {
            var targetPropertyName = property.Name;
            // 从特性获取信息
            var attributeParameters = GetDataFromPropertyAttribute(
                attributeData,
                ref targetPropertyName,
                out var converterType
            );
            // 检查属性
            if (
                GetTargetProperty(mapInfo, property, targetPropertyName)
                is not IPropertySymbol targetProperty
            )
                return null;
            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenRValueNotNullOrDefault),
                    out var mapWhenR
                ) && mapWhenR.Value is true
            )
            {
                if (targetProperty.Type.IsValueType)
                    writer.WriteLine($"if(target.{targetPropertyName} == default)");
                else
                    writer.WriteLine($"if(target.{targetPropertyName} is not null)");
            }

            if (
                attributeParameters.TryGetValue(
                    nameof(MapPropertyAttribute.MapWhenLValueNullOrDefault),
                    out var mapWhenL
                ) && mapWhenL.Value is true
            )
            {
                if (property.Type.IsValueType)
                    writer.WriteLine($"if(source.{property.Name} == default)");
                else
                    writer.WriteLine($"if(source.{property.Name} is null)");
            }

            if (converterType is not null)
            {
                if (
                    CheckConverter(
                        property,
                        targetProperty,
                        attributeData,
                        converterType,
                        out var isAsync
                    )
                )
                {
                    var converterName = GetConverterName(writer, mapInfo, converterType);
                    if (isAsync)
                    {
                        writer.WriteLine(
                            $"source.{property.Name} = await {converterName}.{nameof(MapConverter<int, int>.ConvertBack)}(target, target.{targetPropertyName});"
                        );
                    }
                    else
                    {
                        writer.WriteLine(
                            $"source.{property.Name} = {converterName}.{nameof(MapConverter<int, int>.ConvertBack)}(target, target.{targetPropertyName});"
                        );
                    }
                }
            }
            else
            {
                GenerateStandardProperty(writer, mapInfo, property, targetProperty);
            }
            return targetProperty;
        }

        void GenerateStandardProperty(
            IndentedTextWriter writer,
            MapInfo mapInfo,
            IPropertySymbol property,
            IPropertySymbol targetProperty
        )
        {
            // 比较当前属性与目标属性的类型
            if (SymbolEqualityComparer.Default.Equals(property.Type, targetProperty.Type))
            {
                writer.WriteLine($"source.{property.Name} = target.{targetProperty.Name};");
            }
            else
            {
                // 如果是Task类型
                var taskResultType = property.Type.GetTaskResult();
                if (SymbolEqualityComparer.Default.Equals(property.Type, taskResultType))
                {
                    writer.WriteLine(
                        $"source.{property.Name} = await target.{targetProperty.Name};"
                    );
                }
                else
                {
                    var diagnostic = Diagnostic.Create(
                        Descriptors.TargetPropertyTypeDifferent,
                        property.Locations[0],
                        targetProperty.ToString(),
                        targetProperty.Type.GetFullNameAndGeneric(),
                        mapInfo.MethodName
                    );
                    ExecutionContext.ReportDiagnostic(diagnostic);
                }
            }
        }
    }

    private string? CheckAsyncMapConfigInfo(
        MapInfo mapInfo,
        IPropertySymbol property,
        AttributeData? attributeData
    )
    {
        // 如果这个属性在映射设置中有添加
        if (
            mapInfo.ConfigType is null
            || !MapperConfigInfoByType.TryGetValue(mapInfo.ConfigType, out var mapConfigInfo)
            || !mapConfigInfo.TryGetValue(property.Name, out var isAsync)
        )
            return null;

        if (attributeData is not null)
        {
            var diagnostic = Diagnostic.Create(
                Descriptors.MapHasBeenAdded,
                attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                    attributeData.ApplicationSyntaxReference.Span
                ),
                mapInfo.ConfigType.GetFullNameAndGeneric()
            );
            ExecutionContext.ReportDiagnostic(diagnostic);
        }
        if (isAsync)
        {
            mapInfo.IsAsync = true;
            return $"await config.{nameof(MapperConfig<int, int>.GetMapActionAsync)}(\"{property.Name}\",source, target);";
        }
        else
        {
            return $"config.{nameof(MapperConfig<int, int>.GetMapAction)}(\"{property.Name}\",source, target);";
        }
    }
    #endregion

    private void GenerateEndMapAction(IndentedTextWriter writer, MapInfo mapInfo)
    {
        // 添加映射结束行动
        if (mapInfo.ConfigType is not null)
        {
            var method = mapInfo.ConfigType.FindMember<IMethodSymbol>(
                nameof(MapperConfig<int, int>.EndMapAction)
            );
            if (method is not null)
            {
                writer.WriteLine(
                    $"{mapInfo.ConfigType.GetUnderlineFullName()}.{nameof(MapperConfig<int, int>.EndMapAction)}(source,target);"
                );
            }

            var asyncMethod = mapInfo.ConfigType.FindMember<IMethodSymbol>(
                nameof(MapperConfig<int, int>.EndMapActionAsync)
            );
            if (asyncMethod is not null)
            {
                if (mapInfo.InvokeState.HasFlag(MapMethodInvokeState.Async))
                {
                    writer.WriteLine(
                        $"await {mapInfo.ConfigType.GetUnderlineFullName()}.{nameof(MapperConfig<int, int>.EndMapActionAsync)}(source,target);"
                    );
                }
                else
                {
                    writer.WriteLine(
                        $"{mapInfo.ConfigType.GetUnderlineFullName()}.{nameof(MapperConfig<int, int>.EndMapActionAsync)}(source,target).Wait();"
                    );
                }
                mapInfo.IsAsync = true;
            }
        }
    }

    private void GenerateBeginMapAction(IndentedTextWriter writer, MapInfo mapInfo)
    {
        // 添加映射开始行动
        if (mapInfo.ConfigType is not null)
        {
            var method = mapInfo.ConfigType.FindMember<IMethodSymbol>(
                nameof(MapperConfig<int, int>.BeginMapAction)
            );
            if (method is not null)
            {
                writer.WriteLine(
                    $"config.{nameof(MapperConfig<int, int>.BeginMapAction)}(source,target);"
                );
            }

            var asyncMethod = mapInfo.ConfigType.FindMember<IMethodSymbol>(
                nameof(MapperConfig<int, int>.BeginMapActionAsync)
            );
            if (asyncMethod is not null)
            {
                if (mapInfo.InvokeState.HasFlag(MapMethodInvokeState.Async))
                {
                    writer.WriteLine(
                        $"await config.{nameof(MapperConfig<int, int>.BeginMapActionAsync)}(source,target);"
                    );
                }
                else
                {
                    writer.WriteLine(
                        $"{mapInfo.ConfigType.GetUnderlineFullName()}.{nameof(MapperConfig<int, int>.BeginMapActionAsync)}(source,target).Wait();"
                    );
                }
                mapInfo.IsAsync = true;
            }
        }
    }

    private string? CheckMapConfigInfo(
        MapInfo mapInfo,
        IPropertySymbol property,
        AttributeData? attributeData
    )
    {
        // 如果这个属性在映射设置中有添加
        if (
            mapInfo.ConfigType is null
            || !MapperConfigInfoByType.TryGetValue(mapInfo.ConfigType, out var mapConfigInfo)
            || !mapConfigInfo.TryGetValue(property.Name, out var isAsync)
        )
            return null;

        if (attributeData is not null)
        {
            var diagnostic = Diagnostic.Create(
                Descriptors.MapHasBeenAdded,
                attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                    attributeData.ApplicationSyntaxReference.Span
                ),
                mapInfo.ConfigType.GetFullNameAndGeneric()
            );
            ExecutionContext.ReportDiagnostic(diagnostic);
        }
        if (isAsync)
        {
            return $"config.{nameof(MapperConfig<int, int>.GetMapActionAsync)}(\"{property.Name}\",source, target).Wait();";
        }
        else
        {
            return $"config.{nameof(MapperConfig<int, int>.GetMapAction)}(\"{property.Name}\",source, target);";
        }
    }

    private Dictionary<INamedTypeSymbol, Dictionary<string, bool>> GetMapperConfigInfos(
        GeneratorExecutionContext context
    )
    {
        var mapperConfigInfoByType = new Dictionary<INamedTypeSymbol, Dictionary<string, bool>>(
            SymbolEqualityComparer.Default
        );
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            return mapperConfigInfoByType;
        foreach (var classDeclaration in receiver.CandidateClasses)
        {
            var semanticModel = Compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
            if (
                SymbolEqualityComparer.Default.Equals(
                    classSymbol?.BaseType?.OriginalDefinition,
                    MapConfigType
                )
                is false
            )
                continue;
            var mapConfigInfo = new Dictionary<string, bool>();
            mapperConfigInfoByType.Add(classSymbol!, mapConfigInfo);
            var ctor = classDeclaration
                .Members.OfType<ConstructorDeclarationSyntax>()
                .FirstOrDefault(x => x.ParameterList.Parameters.Count == 0);

            if (ctor is null)
                continue;
            foreach (var invocation in ctor.DescendantNodes().OfType<InvocationExpressionSyntax>())
            {
                if (
                    invocation.Expression is not IdentifierNameSyntax identifier
                    || (
                        identifier.Identifier.Text != nameof(MapperConfig<int, int>.AddMap)
                        && identifier.Identifier.Text != nameof(MapperConfig<int, int>.AddMapAsync)
                    )
                )
                    continue;
                var isAsync = identifier.Identifier.Text != nameof(MapperConfig<int, int>.AddMap);
                var memberName = GetMemberName(invocation, out var lambdaExpression);
                if (
                    string.IsNullOrWhiteSpace(memberName) is false
                    && mapConfigInfo.TryAdd(memberName, isAsync) is false
                )
                {
                    var diagnostic = Diagnostic.Create(
                        Descriptors.SameMapPropertyConfig,
                        lambdaExpression.Body.GetLocation(),
                        memberName
                    );
                    ExecutionContext.ReportDiagnostic(diagnostic);
                }
            }
        }
        return mapperConfigInfoByType;
    }

    private static string GetMemberName(
        InvocationExpressionSyntax invocation,
        out SimpleLambdaExpressionSyntax lambdaExpression
    )
    {
        lambdaExpression = null!;
        var memberName = string.Empty;
        if (
            invocation.ArgumentList.Arguments[0].Expression
            is not SimpleLambdaExpressionSyntax lambda
        )
        {
            return memberName;
        }
        lambdaExpression = lambda;
        if (lambdaExpression.Body is MemberAccessExpressionSyntax body)
        {
            memberName = body.Name.ToString();
        }
        if (lambdaExpression.Body is PostfixUnaryExpressionSyntax postfix)
        {
            if (postfix.Operand is MemberAccessExpressionSyntax member)
                memberName = member.Name.ToString();
        }
        return memberName;
    }

    private IPropertySymbol? GetTargetProperty(
        MapInfo target,
        IPropertySymbol property,
        string? targetPropertyName
    )
    {
        // 目标属性不存在
        if (
            target.TargetType.FindMemberIncludingBaseTypes<IPropertySymbol>(targetPropertyName!)
            is not IPropertySymbol targetProperty
        )
        {
            if (target.ScrutinyMode)
            {
                var diagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyNotExists,
                    property.Locations[0],
                    target.TargetType.GetFullNameAndGeneric() + "." + property.Name
                );
                ExecutionContext.ReportDiagnostic(diagnostic);
            }
            return null;
        }
        // 只读属性
        if (targetProperty.SetMethod is null)
        {
            if (target.ScrutinyMode)
            {
                var diagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyIsReadOnly,
                    property.Locations[0],
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(diagnostic);
            }
            return null;
        }
        // 静态属性
        if (targetProperty.IsStatic)
        {
            if (target.ScrutinyMode)
            {
                var diagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyIsStatic,
                    property.Locations[0],
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(diagnostic);
            }
            return null;
        }
        if (targetProperty.SetMethod.DeclaredAccessibility == Accessibility.Public)
            return targetProperty;
        // 可访问性为本地或保护本地
        if (
            (
                targetProperty.SetMethod.DeclaredAccessibility == Accessibility.Internal
                || targetProperty.SetMethod.DeclaredAccessibility
                    == Accessibility.ProtectedOrInternal
            )
        )
        {
            // 在主程序集
            if (
                SymbolEqualityComparer.Default.Equals(
                    targetProperty.SetMethod.ContainingAssembly,
                    Compilation.Assembly
                )
            )
                return targetProperty;
            if (target.ScrutinyMode)
            {
                var diagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyInsufficientAccessibility,
                    property.Locations[0],
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(diagnostic);
            }
            return null;
        }
        // 更低的可访问性
        if (targetProperty.SetMethod.DeclaredAccessibility < Accessibility.Internal)
        {
            if (target.ScrutinyMode)
            {
                var diagnostic = Diagnostic.Create(
                    Descriptors.TargetPropertyInsufficientAccessibility,
                    property.Locations[0],
                    targetProperty.ToString()
                );
                ExecutionContext.ReportDiagnostic(diagnostic);
            }
            return null;
        }
        return targetProperty;
    }

    private bool CheckConverter(
        IPropertySymbol property,
        IPropertySymbol targetProperty,
        AttributeData attributeData,
        INamedTypeSymbol converterType,
        out bool isAsync
    )
    {
        isAsync = false;
        var converterSourceType = converterType.BaseType!.TypeArguments[0];
        // 比较转换器当前属性与当前属性的类型
        if (SymbolEqualityComparer.Default.Equals(property.Type, converterSourceType) is false)
        {
            var taskResultType = converterSourceType.GetTaskResult();
            if (SymbolEqualityComparer.Default.Equals(property.Type, taskResultType) is false)
            {
                var diagnostic = Diagnostic.Create(
                    Descriptors.ConverterCurrentTypeDifferentNoMethod,
                    attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                        attributeData.ApplicationSyntaxReference.Span
                    ),
                    converterSourceType.GetFullNameAndGeneric(),
                    property.Type.GetFullNameAndGeneric()
                );
                ExecutionContext.ReportDiagnostic(diagnostic);
                return false;
            }
            else
                isAsync = true;
        }
        var converterTargetType = converterType.BaseType!.TypeArguments[1];
        // 比较转换器目标属性与目标属性的类型
        if (
            SymbolEqualityComparer.Default.Equals(targetProperty.Type, converterTargetType) is false
        )
        {
            var taskResultType = converterTargetType.GetTaskResult();
            if (SymbolEqualityComparer.Default.Equals(targetProperty.Type, taskResultType) is false)
            {
                var diagnostic = Diagnostic.Create(
                    Descriptors.ConverterTargetTypeDifferentNoMethod,
                    attributeData.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                        attributeData.ApplicationSyntaxReference.Span
                    ),
                    converterTargetType.GetFullNameAndGeneric(),
                    targetProperty.Type.GetFullNameAndGeneric()
                );
                ExecutionContext.ReportDiagnostic(diagnostic);
                return false;
            }
            else
                isAsync = true;
        }
        return true;
    }

    private Dictionary<string, AttributeParameterValue> GetDataFromPropertyAttribute(
        AttributeData attributeData,
        ref string? targetPropertyName,
        out INamedTypeSymbol? converterType
    )
    {
        converterType = null;
        var parameters = attributeData.GetAttributeParameterInfos();
        if (parameters.Count == 0)
            return parameters;

        if (parameters.TryGetValue(nameof(MapPropertyAttribute.PropertyName), out var nameData))
        {
            var name = nameData.Value?.ToString();
            if (string.IsNullOrWhiteSpace(name) is false)
                targetPropertyName = name;
        }
        if (
            parameters.TryGetValue(
                nameof(MapPropertyAttribute.ConverterType),
                out var converterData
            )
        )
        {
            converterType = converterData.Value as INamedTypeSymbol;
            if (
                converterType?.InheritedFrom("HKW.HKWMapper.MapConverter<TValue, TTarget>") is false
            )
                converterType = null;
        }
        return parameters;
    }

    private Dictionary<INamedTypeSymbol, MapperMethods> GetMapTargetAndMethod(
        SemanticModel semanticModel,
        IEnumerable<ClassDeclarationSyntax> declaredClasses
    )
    {
        var mapMethodsByType = new Dictionary<INamedTypeSymbol, MapperMethods>(
            SymbolEqualityComparer.Default
        );
        foreach (var declaredClass in declaredClasses)
        {
            var classSymbol = (INamedTypeSymbol)
                ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass)!;
            var attributeDatas = classSymbol
                .GetAttributes()
                .Where(x =>
                    x.AttributeClass!.ToString() is string name
                    && (
                        name == typeof(MapToAttribute).FullName
                        || name == typeof(MapFromAttribute).FullName
                    )
                );
            var methodNames = new HashSet<string>();
            foreach (var attribute in attributeDatas)
            {
                var attributeName = attribute.AttributeClass!.GetFullName();
                if (attributeName == typeof(MapToAttribute).FullName)
                {
                    var mapInfo = CreateMapInfo(classSymbol, attribute, true);
                    if (mapInfo is null)
                        continue;
                    if (mapMethodsByType.TryGetValue(classSymbol, out var targets) is false)
                        targets = mapMethodsByType[classSymbol] = new([], []);
                    targets.ToMethodInfos.Add(mapInfo);
                    if (methodNames.Add(mapInfo.MethodName) is false)
                    {
                        var diagnostic = Diagnostic.Create(
                            Descriptors.SameMethodName,
                            attribute.ApplicationSyntaxReference?.SyntaxTree.GetLocation(
                                attribute.ApplicationSyntaxReference.Span
                            ),
                            mapInfo.MethodName
                        );
                        ExecutionContext.ReportDiagnostic(diagnostic);
                    }
                }
                else if (attributeName == typeof(MapFromAttribute).FullName)
                {
                    var mapInfo = CreateMapInfo(classSymbol, attribute, false);
                    if (mapInfo is null)
                        continue;
                    if (mapMethodsByType.TryGetValue(classSymbol, out var targets) is false)
                        targets = mapMethodsByType[classSymbol] = new([], []);
                    targets.FromMethodInfos.Add(mapInfo);
                    if (methodNames.Add(mapInfo.MethodName) is false)
                    {
                        var diagnostic = Diagnostic.Create(
                            Descriptors.SameMethodName,
                            attribute.ApplicationSyntaxReference?.SyntaxTree.GetLocation(
                                attribute.ApplicationSyntaxReference.Span
                            ),
                            mapInfo.MethodName
                        );
                        ExecutionContext.ReportDiagnostic(diagnostic);
                    }
                }
            }
        }
        return mapMethodsByType;
    }

    private MapInfo? CreateMapInfo(
        INamedTypeSymbol classSymbol,
        AttributeData attribute,
        bool isMapTo
    )
    {
        var parameters = attribute.GetAttributeParameters();
        if (parameters.Count == 0)
            return null;
        if (
            parameters.TryGetValue<INamedTypeSymbol>(
                nameof(MapToAttribute.TargetType),
                out var targetType
            )
            is false
        )
            return null;
        parameters.TryGetValue<string>(nameof(MapToAttribute.TargetName), out var targetName);
        parameters.TryGetValue<bool>(nameof(MapToAttribute.ScrutinyMode), out var scrutiny);
        parameters.TryGetValue<INamedTypeSymbol>(
            nameof(MapToAttribute.MapperConfig),
            out var mapConfigType
        );
        parameters.TryGetValue<MapMethodInvokeState>(
            nameof(MapToAttribute.InvokeState),
            out var invokeState
        );
        targetName ??= targetType.Name;
        var methodName = isMapTo ? $"MapTo{targetName}" : $"MapFrom{targetName}";
        mapConfigType = CheckMapConfig(classSymbol, attribute, targetType, mapConfigType);
        return new(attribute, classSymbol, targetType, methodName)
        {
            ConfigType = mapConfigType,
            ScrutinyMode = scrutiny,
            IsMapTo = isMapTo,
            InvokeState = invokeState == default ? MapMethodInvokeState.Sync : invokeState
        };
    }

    private INamedTypeSymbol? CheckMapConfig(
        INamedTypeSymbol classSymbol,
        AttributeData attribute,
        INamedTypeSymbol targetType,
        INamedTypeSymbol? mapConfigType
    )
    {
        if (
            SymbolEqualityComparer.Default.Equals(
                mapConfigType?.BaseType?.OriginalDefinition,
                MapConfigType
            )
            is false
        )
            return null;

        if (mapConfigType?.BaseType is not INamedTypeSymbol baseType)
            return null;

        var configSourceType = baseType.TypeArguments[0];
        var configTargetType = baseType.TypeArguments[1];
        // 检查IMapConfig的类型
        if (SymbolEqualityComparer.Default.Equals(classSymbol, configSourceType))
        {
            if (SymbolEqualityComparer.Default.Equals(targetType, configTargetType))
            {
                return mapConfigType;
            }
            var diagnostic = Diagnostic.Create(
                Descriptors.MapConfigTargetTypeDifferent,
                attribute.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                    attribute.ApplicationSyntaxReference.Span
                ),
                configTargetType.GetFullNameAndGeneric(),
                targetType.GetFullNameAndGeneric()
            );
            ExecutionContext.ReportDiagnostic(diagnostic);
        }
        else
        {
            var diagnostic = Diagnostic.Create(
                Descriptors.MapConfigSourceTypeDifferent,
                attribute.ApplicationSyntaxReference!.SyntaxTree.GetLocation(
                    attribute.ApplicationSyntaxReference.Span
                ),
                configTargetType.GetFullNameAndGeneric(),
                classSymbol.GetFullNameAndGeneric()
            );
            ExecutionContext.ReportDiagnostic(diagnostic);
        }

        return null;
    }
}

internal record struct MapMethodAndAttributeName(string MethodName, string AttributeName);

internal record struct MapperMethods(
    HashSet<MapInfo> ToMethodInfos,
    HashSet<MapInfo> FromMethodInfos
);
